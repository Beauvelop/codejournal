<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<div class="node-container">
  <aside><span class="rot90">{{state}}</span></aside>
  <div class="node-entry entry">
<pre>

  <div class="slate-skyblue-fr ctr"><h2 class="chtitle lt thin">Back to Front:<i class="med"> Connecting node files to your html</i></h2>
    <h3>Endpoints are done... 5 steps to connect</h3>
    <p>index.js needs a reference to an <span class="wh">"assets"</span> folder</p>
<pre class="prettyprint w40 ctr">...

app.use(express.static('assets'));
app.use(bodyParser.json());

// must be placed before the app.use(bodyParser.json());
...</pre>
<p>In the root directory, create the following:</p>
<pre class="shadn w40 ctr">
  New folder<code class="med navy"><span>ðŸ“‚</span>assets</code>
        New file<code class="med navy"><span>ðŸ“„</span>index.html</code>
        New folder<code class="med navy"><span>ðŸ“‚</span>css</code>
              New file<code class="med navy"><span>ðŸ“„</span>master.css</code>
        New folder<code class="med navy"><span>ðŸ“‚</span>js</code>
              New file<code class="med navy"><span>ðŸ“„</span>myScript.js</code>
</pre>
<h3 class="chtitle sm">Restart nodemon in terminal and check devtools network panel for "all"</h3>
<div class="ctr w40"><img class="w40 ctr" src="./img/network1.jpg" alt="network panel in devtools showing html, css & js assets">
</div>
</div>
  <div class="framed8"><h3 class="chtitle">A nice bit of middleware to log queries</h3>
<pre class="dkbg ltgrey">...
var PORT = 5000;
<div class="fRight w40 thin ltgreen"> This is simply a bit of code to help in debugging and logging certain queries on certain endpoints<br />
It isn't necessary on each.<br />
Note: that .next() is run under the hood in express, but it's necessary to place at the end of logQuery<br />
Otherwise, it wont run the 3rd arg in the function signature of the endpoint.</div>
var app = express();

<span class="mutedOrange">var <span class="mango">logQuery</span> = function(req, res, next) {
  console.log('req.query: ', req.query);
  console.log('req.body: ', req.body);
  console.log('req.path: ', req.path);
  <span class="pastpink">next();</span>
}</span>


app.use(bodyParser.json());

app.get('/meals', <span class="mango">logQuery</span>, mealsCtrl.index);
app.get('/meals/:id', mealsCtrl.show);
app.post('/meals', <span class="mango">logQuery</span>, mealsCtrl.create);
app.put('/meals/:id',<span class="mango">logQuery</span>, mealsCtrl.update);
app.delete('/meals/:id', mealsCtrl.destroy);
...
</pre>

  </div>
  <hr>
  <div class="framed6">
    <h3 class="chtitle">Refactoring our <em>index.js</em> file for modularity</h3>
    We have a problem. Our index.js file's endpoints are heavy. There's no modularity. Let's fix this.

    Create a new folder<code class="med navy"><span>ðŸ“‚</span>controllers</code>and a new file<code class="med navy"><span>ðŸ“„</span>meal_ctrl.js</code>



in mealsCtrl.js I create an object with similar RESTful method names (to avoid namespace clashes) for each endpoint
<div class="brdr-w w30 ltgrey ctr ctrtxt CodePro">GET  -> index
GET(/:id) -> show
POST -> create
PUT -> update
DELETE -> destroy</div>

We need to take the "meat" (the function) out of each endpoint and place each onto those new keys in that object.
<pre class="w40 ctr dkbg3 CodePro">app.get('/meals', <span class="dkbg mango">function(req, res, next) {
  if(req.query.cuisine) {
    var queriedMeals = meals.filter(function(meals) {
      return meals.cuisine === req.query.cuisine;
    })
    res.status(200).json(queriedMeals);
    }
  return res.status(200).json(meals);
}</span>)</pre>

Put this object on an export command...<code class="ltgreen">meal_ctrl.js</code>
<pre class="prettyprint dkbg2 w40 ctr">
module.exports = {

  index: function(req, res, next) {
    if(req.query.cuisine) {
      var queriedMeals = meals.filter(function(meals) {
      return meals.cuisine === req.query.cuisine;
      })
      res.status(200).json(queriedMeals);
      }
    return res.status(200).json(meals);
  },

  show: function(req, res, next) {
    var mealID = parseInt(req.params.id);
    res.status(200).json(meals[mealID]);
  },

  create: function(req, res, next) {
    meals.push(req.body);
    res.status(200).json(meals);
  },

  update: function(req, res, next) {
    var mealID = parseInt(req.params.id);
    meals[mealID] = req.body;
    res.status(200).json(meals[mealID]);
  },

  destroy: function(req, res, next) {
    var mealID = parseInt(req.params.id);
    var deletedMeal = meals.splice(mealID, 1)[0];
    res.status(200).json(deletedMeal);
  }

}
</pre>

We, then require it in index.js
<pre class="prettyprint w40">var mealsCtrl = require("./controllers/meal_ctrl");</pre>(".js" not necessary in Node.js paths)

Finally, we need to clean up the endpoints to reference the imported object
<pre class="dkbg">app.get('/meals', mealsCtrl.index);
app.get('/meals/:id', mealsCtrl.show);
app.post('/meals', mealsCtrl.create);
app.put('/meals/:id',logQuery, mealsCtrl.update);;
app.delete('/meals/:id', mealsCtrl.destroy);</pre>
<span class="ltgreen">We've dried up lots of code, but we're not done yet.</span>

We can increase the modularity by extracting the Array that we query into a new file.

Create a new folder<code class="med navy"><span>ðŸ“‚</span>models</code>and a new file<code class="med navy"><span>ðŸ“„</span>meals.js</code>

<pre class="w30 dkblue ltbg ctr">module.exports = [{
    "entree": "Burgers",
    "dessert": "Ice Cream",
    "cuisine": "American"
  },
  {
    "entree": "Sushi",
    "dessert": "Asian Pears",
    "cuisine": "Japanese"
  },
  {
    "entree": "Linguini",
    "dessert": "Tiramisu",
    "cuisine": "Italian"
  }
];</pre>

<h4 class="chtitle dkblue"><span class="softred">IMPORTANT:</span> We next require this Object FROM WITHIN THE<code class="dkred">meal_ctrl.js</code>file!</h4>
<h4>Therefore, we need: <br> <code class="dkblue med">var meals = require("../models/meals");</code> </h4>
  <h4 class="chtitle softred clean">DO NOT FAIL TO NOTICE: the "../" that takes us back to the root of the directory to find the models folder</h4>


  </div>
  <hr>
<div class="simple-frame4"><h3 class="chtitle">Example of a <em>index.js</em> file with one simple endpoint</h3>
<div class="fRight w40">
<span class="sm wh">01.</span> We've introduced two bits of middle-ware here. We call express on app for each endpoint.

Express provides functions for REST routes, header handling & methods for parsing POST requests.

<span class="sm wh">04.</span>establishes the port that listens on an infinite loop (on local server)

<span class="sm wh">08.</span> (obect to query is in this file for now, but belongs elsewhere for modularity).

<span class="sm wh">25.</span> bodyParser is called on each request with this line and adds it to the req.

<span class="sm wh">30.</span> "res" simply is an empty object that you build to create a response

<span class="sm wh">34.</span>runs on the "nodemon" command in terminal to confirm that server is ready for a request.
</div>
<pre class="prettyprint w40 linenums pRel">
var express = require('express');
var bodyParser = require('body-parser');

var PORT = 5000;

var app = express();

var meals = [{
    "entree": "Burgers",
    "dessert": "Ice Cream",
    "cuisine": "American"
  },
  {
    "entree": "Sushi",
    "dessert": "Asian Pears",
    "cuisine": "Japanese"
  },
  {
    "entree": "Linguini",
    "dessert": "Tiramisu",
    "cuisine": "Italian"
  }
];

app.use(bodyParser.json());

/*GET endpoint ----------------- */
app.get('/meals', function(req, res, next) {
  res.status(200).json(meals);
})


app.listen(PORT, function() {
  console.log("Listening on", PORT);
});
</pre>
<h3>Given the first arg of app.get(/meals, ...) All will be available at <code class="paleY">localhost:5000/meals</code></h3>
<hr>
<p class="med">From here, handling a variable id is very straightforward. Our object is an Array of Objects

Let's imagine our path looks like this: <code class="dkred">localhost:5000/meals/<span class="ltred">1</span></code>

A modified<code class="ltgreen">GET</code>can provide for that index in the array in the following way:</p>
<pre class="prettyprint w50 ctr">app.get('/meals/:id', function(req, res, next) {
  var mealID = parseInt(req.params.id);
  res.status(200).json(meals[mealID]);
})
</pre>
<h3 class="w60 ctr">The var<code>mealID</code>will equal any num in that url path &<code>req.params</code>performs this magic.</h3>

<h3>A<code class="ltgreen">POST</code>(appends nicely with javascript's<code>.push()</code>method:</h3>
<pre class="prettyprint w50 ctr">app.post('/meals', function(req, res, next) {
  meals.push(req.body);
  res.status(200).json(meals);
})</pre>

<h3>A<code class="ltgreen">DELETE</code>,too, will need<code>req.params.id</code>to zero-in on an index:</h3>
<pre class="prettyprint w50 ctr">app.delete('/meals/:id', function(req, res, next) {
  var mealID = parseInt(req.params.id);
  var deletedMeal = meals.splice(mealID, 1)[0];
  res.status(200).json(deletedMeal);
})
// .splice() returns an array of one. Appending [0] gives us that index.</pre>

<hr>
<p class="med dkmango">Let's recognize that <br />1)<code class="dkred">localhost:5000/meals</code>is "path"...<br />
2) The question mark<code class="navy med">?</code> (and what follows) is "query"...</p>

<br />Example url:
<h3 class="chtitle"><code class="dkred lg">localhost:5000/meals<span class="softred"><span class="navy med">?</span>cuisine=Italian</span></code></h3>
<div class="w40 brdr-w ctr">Our<code class="navy lg">?</code>creates an object with key:value pairs</div>
<pre class="prettyprint w50 ctr">app.get('/meals', function(req, res, next) {
  console.log("req.query: ", req.query);
  res.status(200).json(meals);
})
// req.query: { cuisine: 'Italian' }</pre>
<hr>This URL:<br />
<h3 class="chtitle"><code class="dkred">localhost:5000/meals?cuisine=Italian</code></h3>
<br />
<br />Into this endpoint:
<span class="fRight w20 ltgreen sm">.filter() method will return whatever matches the boolean comparison</span>
<pre class="w40 ctr prettyprint">app.get('/meals', function(req, res, next) {
  var queriedMeals = meals.filter(function(meals) {
    return meals.cuisine === req.query.cuisine;
  })
  res.status(200).json(queriedMeals);
})</pre>

<br />Renders this result:
<pre class="w40 ctr dkbg3">[
    {
        "entree": "Linguini",
        "dessert": "Tiramisu",
        "cuisine": "Italian"
    }
]</pre>

<br />Remember: urls and endpoints are case-sensitive strings.
<h3 class="paleY"><code>localhost:5000/meals?cuisine=italian</code></h3>
would give render a sad, lonely, empty array <code class="ltgreen">// []</code>
<br />
<br />The same is true for no query!
<h3 class="paleY"><code>localhost:5000/meals</code></h3>
again <code class="ltgreen">// []</code>

<br><br>How, then, do we configure the above endpoint to handle <em>no</em> queries?<br />
<pre class="dkbg3 sm w40 ctr">app.get('/meals', function(req, res, next) {
  <span class="orange">if (req.query.cuisine) {</span>
      var queriedMeals = meals.filter(function(meals) {
      return meals.cuisine === req.query.cuisine;
    })
    res.status(200).json(queriedMeals);
  <span class="orange">}</span>
  return res.status(200).json(meals);
})</pre>


</div>
<hr>
  <div class="forest-red-fr">
A session is something on the back end that is stored as an ID--associated to an object.
A cookie is the mechanism by which we pass that ID back and forth.

.sid = session id.
(express-session is built on top of <em>Connect</em>)
<img class="w40" src="./img/sessionID.png" alt="sessionID">
This is what gets tossed back and forth on each of our requests.

  </div>

<!-- end of pre for all -->
  </div>
  <!-- end of entry -->


</div>
<!-- end of node container -->
