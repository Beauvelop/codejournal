<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<div class="react-container">
  <aside><span class="rot90">{{state}}</span></aside>
  <div class="react-entry entry">
    <pre>
    <!--entire page pre-->
    <div class="plain-frame3"><img class="w20 fRight" src="./img/colornum.png" alt="colornum">
      <h2 class="chtitle">Two Buttons iterating on an array to style a component</h2>
      <div class="brdr-w">
        fiddle:
        <script class="w50 ctr" async src="//jsfiddle.net/beau_dev/xkkxb5a9/3/embed/js,html,css,result/dark/"></script>
      </div>

<pre class="w50 prettyprint ctr">
class Button extends React.Component {
  clickHandle = () => {
  	this.props.clickFunk(this.props.modifier)
  }
  render() {
    return (
      < button onClick={this.clickHandle}>{this.props.modifier}< / button>
    )
  }
};
</pre>
<p>A simple class Button component with a clickhandler. We know that clickFunk is on props and likely in the parent "App" class component.</p>
<pre class="w50 prettyprint ctr">
const Result =(props) => {
 	colors = ["red", "blue", "green", "orange", "gold", "grey", "white", "black", "navy", "burlywood", "lightgreen", "fuchsia", "slategrey", "purple"];

	rezStyle = { color: colors[props.read] };

	return (
      < h1 style={this.rezStyle}>Color Number: {props.read}< / h1>
    )
}
</pre>
<p>Array of colors placed in function component. props.read will be revealed to be an incrementing/decrementing number selecting indices in the array to determine component styles.</p>
<pre class="w50 prettyprint ctr">
  class App extends React.Component {
  	state = { counter: 0};

    modify = (modifier) => {
       this.setState((prevState) => ({
            counter: prevState.counter + modifier
          }))
      }

  render() {
    	return (
      	< div>
      	  < Button modifier={1} clickFunk={this.modify}/>
      	  < Button modifier={-1} clickFunk={this.modify}/>
          < Result read={this.state.counter}/>
      	< / div>
      )
    }
  }</pre>
<p>One button modifies up, one button modifies down. ClickFunk triggers modify. <em>prevState</em>, here, is important to avoid a race-condition in case values in a larg application are batched.
<br />
PrevState is used often in the case that state is updated with itsown state.</p>

<div class="softsand-bg wh"><h4>Perhaps the most important line of code (for the meantime) is the clickhandler at in the button class component<br />
<code class="dkblue">clickHandle = () => {
  this.props.clickFunk(this.props.modifier)
}</code><br />
it calls clickFunk and uses the hardcoded number inside of the btn component's "token"(< Button / >) inside of the parent App class component.</h4>
</div>
</div>
<hr>
<div class="plain-frame1">
   <h2 class="chtitle">Replacing a constructor call and super() with a class property. <em>(es7)</em></h2>

   <p class="fRight dkbg">(c/o  <a  href="https://app.pluralsight.com/library/courses/react-js-getting-started/table-of-contents" target="_blank">Pluralsight</a>)</p>

  Before...
  <pre class="prettyprint w40">class Btn extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0
    };
  }
  render() {
    return < button>{this.state.counter}< / button>;
  }
}</pre>
After...
<pre class="prettyprint w40">class Btn extends React.Component{
	var state = {counter:0};
    render() {
      return (
        < button>{this.state.counter}< / button>
      )
    }
  }</pre>

  Placing a clickHandler and a prototype function on a class.
  <pre class="ctr prettyprint w40">class Btn extends React.Component{
	state = {counter:0};
  handleClick =() => { // handleClick is a prototype function on this class...
  //the keyword 'this' acts as a component instance that is sent to the DOM
    this.setState({
      counter: this.state.counter + 1
    });
	}
    render() {
      return (
        < button onClick={this.handleClick}>
        {this.state.counter}
        < / button>
      )
    }
  }</pre>
  <h3>Avoiding Race-conditions...</h3>
  React's setState method is async. So multiple state-calls can be batched for performance. Therefore, the general rule is:
  Whenever you need to update a component's state using a value from the current state -- Use the other contract of setState() method--
  which is a function instead of an object.
  <br />
  This function receives a previousState object...and the func returns the object which we want to use.

  <pre class="prettyprint brdr-w w40 ctr"> handleClick =() => {
    this.setState((prevState) => {
    	return {
      	counter: prevState.counter + 1
    	}
    });
	}</pre>
  **You only need to use this if your update depends on the current state.
  **Also... using es6 we can get rid of the return & curlies...
  <pre class="prettyprint brdr-w w40 ctr"> handleClick =() => {
    this.setState((prevState) => {
    	return {
      	counter: prevState.counter + 1
    	}
    });
	}</pre>
<hr>
<h3 class="chtitle">Two components... One that feeds & one that reads.</h3>
<pre class="prettyprint w50 ctr">class Btn extends React.Component{
  render() {
    return (
      < button onClick={this.props.onClickFunction}>Add< / button>
    )
  }
}
const Result =(props) => {
  return (
    < div>{props.getCounter}< / div>
  )
}
class App extends React.Component {
  state = {counter:0};

  incrementCounter = () => {
  	  this.setState((prevState) => ({
      	counter: prevState.counter + 1
    }));
  }

  render() {
    	return (
      	< div>
      	  < Btn onClickFunction={this.incrementCounter}/>
      	  < Result getCounter={this.state.counter}/>
      	< / div>
      )
    }
  }
ReactDOM.render(<App/>, mountNode);</pre>
Here, the state changes on the App component level...(i.e. the Parent). So there is access to it from both sub-components Btn & Result.


</div>
    <div class="softsand-bg brdr-b dkblue">
      <h1 class="ctrtxt softwhite thin">Sample react static component <em class="softred">...reformatted</em></h1>
      <h5 class="fRight">With special thanks to <a target="_blank" href="https://reactforbeginners.com/">Wesbos</a></h5>

Feeding to a component is app.js
  <pre class="w50 prettyprint ctr">import React from 'react';
import Winner from './Winner';

class App extends React.Component {
    render() {
        return(
            < div className="announcement">
                < div className="news">
                 < Winner tagline="John Wilson"/>
                < /div>
            < /div>
        )
    }
}

export default App; </pre>

Winner.js
<pre class="prettyprint w50 ctr">import React from 'react';

class Winner extends React.Component {
    render() {
        return (
            < header className="employee-of-month">
                < h1>Congratulations!< /h1>
                < h2 className="tagline">{this.props.winner}< /h2>
                < h3 className="jobtitle">< /h3>
                < h5 className="department">< /h5>
            < /header >
        )
    }
}

export default Winner;
</pre>
This component simply renders html to the DOM. It only does one thing.
So, we only need a "Stateless Functional Component". We only need render();

1) Delete the class component
2) Delete the "render() { ...}"
3) Put the whole thing on a function definition returning the whole thing.
4) Make sure this function is passed <em class="dkorange med">props</em>...
5) remove <em>this</em> it is undefined
<pre class="prettyprint w50 ctr">import React from 'react';

const Winner = (props) => {
  return (
      < header className="employee-of-month">
          < h1>Congratulations!< /h1>
          < h2 className="tagline">{props.winner}< /h2>
          < h3 className="jobtitle">< /h3>
          < h5 className="department">< /h5>
      < /header >
  )
}

export default Winner;
</pre>

    </div>
    <div class="simple-wine-frame thin softwhite"><h1 class="ctrtxt wh">Barest Bones of a React Component</h1>
(This is without JSX)
      <pre class="dkbg2 w60 ctr">
<pre class="dkbg softwhite fRight brdr-w med thin">
< div id="app">
  < div data-reactroot>
    < div class="first">
        < h4 style="color: navy;">Homeland< / h4>
    < /div>
  < /div>
< /div>
</pre>
const ce = React.createElement;

const <span class="paleY">MyTitle</span> = function(<span class="ltgreen">props</span>) {
  return ce(
   'div',
   null,
   ce(
    'h4',
    { style: {
        color: <span class="ltgreen">props</span>.color
      }
    },
    <span class="ltgreen">props</span>.title
   )
  );
};

const <span class="ltred">MyFirstComponent</span> = function() {
  return ce(
    'div',
    {
      id: 'first'
    },
    ce(<span class="paleY">MyTitle</span>,{
      title: 'Homeland',
      color: 'navy'
    })
 );
};

ReactDOM.render(ce(<span class="ltred">MyFirstComponent</span>), document.getElementById('app'));
</pre>
<hr class="w50">
<h3>Simple example with JSX</h3>
<pre class="prettyprint w50 ctr">import React from 'react';
import { render } from 'react-dom';

// Implicit Return (as if the whole body below were one line) so, () not {}
const App = () => (
  < div className="app">
    < div className="landing">
      < h1>SVIDEO< /h1>
      < input type="text" placeholder="SEARCH" />
      < a>or Browse All< /a>
    < /div>
  < /div>
);

render(<App />, document.getElementById('app'));
</pre>
</div>

<div class="react-frame-light"><h1 class="chtitle dkmango">REACT STATE:</h1>
  <h2 class="ctrtxt">From static component to Stateful component <em>in a few easy steps</em></h2>
<div class="brdr-b w40 ctr ctrtxt">
<p>A component can only modify it's own state
and cannot modify another component's state.
</p>
</div>
<p>Components like this, thus far, don't have state. The input, for example, is an <em>"untracked input"</em></p>
<pre class="prettyprint w60">import React from 'react';
import ShowCard from './ShowCard';
import preload from '../data.json';

const Search = () => (
  < div className="search">
    < div>
      < h1>reactApp< /h1>
      < input type="text" placeholder="search" />
      {preload.shows.map(show => < ShowCard key={show.imdbID} {...show} />)})
    < /div>
  < /div>
);

export default Search;
</pre>
<p>This needs to be transformed into an ES6 class component.</p>
<span class="lg ltred">Q</span> What one thing MUST a class Component have?  <span class="ans ltred med">a render method</span>
<span class="lg ltred">Q</span> And it must return..?  <span class="ans ltred med">markup</span>
<pre class="dkbg w60">
<span class="orange"><code>class Search extends Component {
    render() {
    return (</span></code>
      < div className="search">
        < div>
          < h1>reactApp< /h1>
          < input type="text" placeholder="search" />
          {preload.shows.map(show => < ShowCard key={show.imdbID} {...show} />)})
        < /div>
      < /div>
    <span class="orange">);
  }
}</span>
</pre>
<p>Further... This class Component must be given a constructor with props and a way to define initial state.
Here, the inital value is 'tied' to whatever I type into the input.</p>
<pre class="dkbg w60">class Search extends Component {
  <span class="orange"><code>constructor(props) {
    super(props);
    this.state = {
      searchTerm: 'This is a test String',
    };
  }</span></code>
  render() {
    return (
      < div className="search">
        < div>
          < h1>reactApp< /h1>
          < input value={this.state.searchTerm} type="text" placeholder="search" />
          {preload.shows.map(show => < ShowCard key={show.imdbID} {...show} />)})
        < /div>
      < /div>
    <span class="orange"><code>);
  }
}</span></code>
</pre>

<p>So with this... I type into input and ABSOLUTELY nothing happens.--Yes, an event fires, yet react will always check what the state is and place it back into the browser as the value of input!</p>

<h2 class="ctrtxt clean">Enter...the <code><em>onChange</em> handler!</code> <span class="med">🎉👍🏼</span> Woohoo!</h2>
We use this.setState() to update components local state:
<pre class="dkbg w80">class Search extends Component {
  constructor(props) {
    super(props);
    this.state = {
      searchTerm: 'this is a test String',
    };
  }
<span class="orange"><code>  handleSearchTermChange(event) {
    this.setState({ searchTerm: event.target.value });
  }</span></code>

  render() {
    return (
      < div className="search">
        < div>
          < h1>reactApp< /h1>
          < input<span class="orange"><code>onChange={this.handleSearchTermChange}</span></code>value={this.state.searchTerm} type="text" placeholder="search" />
          {preload.shows.map(show => < ShowCard key={show.imdbID} {...show} />)})
        < /div>
      < /div>
    );
  }
}</pre>
This is fine, but we still haven't called the event on the Search class.

In order to do so, we need to bind this event to the context of Search.

There are many ways to do this... Let's take a look at a worst practice for binding.

<code class="ctrtxt med ltred">onChange={this.handleSearchTermChange.bind(this)}</code>

<pre class="dkbg ctr"><div className="search">
  < div className="search">
   < div>
     < h1>reactApp< /h1>
     < input onChange={this.handleSearchTermChange<span class="ltred">.bind(this)</span>} value={this.state.searchTerm} type="text" placeholder="search" />
     {preload.shows.map(show => < ShowCard key={show.imdbID} {...show} />)})
   < /div>
 < /div>
</pre>
Why is this code crap?
<p><strong class="lg dkblue">Problem:</strong> Render gets called a lot in react --Every time render gets called it will call .bind() and create a new function.
.bind() is an expensive call in javascript.</p>
React will, in fact, throw an error.
<br>
<p><strong class="lg dkblue">Solution:</strong> in the constructor, we place the following:
<br><code class="brdr-w dkorange">this.handleSearchTermChange = this.handleSearchTermChange.bind(this);</code>
</p>
This may look awkward, but it will solve all of our problems.
<pre class="prettyprint linenums">// Search.JSX
import React, { Component } from 'react';
import ShowCard from './ShowCard';
import preload from '../data.json';

class Search extends Component {
  constructor(props) {
    super(props);
    this.state = {
      searchTerm: 'this is a debug statement',
    };
    this.handleSearchTermChange = this.handleSearchTermChange.bind(this); // Boom --Solved!
  }

  handleSearchTermChange(event) {
    this.setState({ searchTerm: event.target.value });
  }

  render() {
    return (
      < div className="search">
        < div>
          < h1>reactApp< /h1>
          < input onChange={this.handleSearchTermChange} value={this.state.searchTerm} type="text" placeholder="search" />
          {preload.shows.map(show => < ShowCard key={show.imdbID} {...show} />)})
        < /div>
      < /div>
    );
  }
}

export default Search;</pre>

<div class="plain-frame1">
  There is <em>yet</em> a more concise bit of wizardry used by Brian Holt in his class on FrontEnd Masters using a stage 2 javascript proposal.

  1) First, we need to update our babelrc file:
  <pre class="prettyprint w40"><code class="sm">
    ...
    ...
        "loose": true,
        "modules": false
        }
      ]
    ],
  <span class="pastY">"plugins": ["babel-plugin-transform-class-properties"]</span>
  }</code></pre>
  2) Next, we need to make sure that eslint.json has the proper parser:
  <pre class="prettyprint w40"><code class="sm">
    ...
    ...
    "plugins": ["prettier"],
    <span class="pastY">"parser": "babel-eslint",</span>
    "parserOptions": {
    ...
  </code></pre>
  Finally, we can delete a good bit of code to make this class more concise.
  Delete: <code class="ltred">this.handleSearchTermChange = this.handleSearchTermChange.bind(this);</code>
  Transform <code>handleSearchTermChange</code> into an arrow function...
  <pre class="prettyprint w60">  handleSearchTermChange = event => {
      this.setState({ searchTerm: event.target.value });
    }</pre>
  Replace the entire constructor function with the object:
  <pre class="dkbg w30"> state = {
      searchTerm: ''
    };</pre>

</div>
<h2 class="ctrtxt clean">Entire working code is much cleaner</h2>
<pre class="prettyprint">import React, { Component } from 'react';
import ShowCard from './ShowCard';
import preload from '../data.json';

class Search extends Component {
  state = {
    searchTerm: '',
  };

  handleSearchTermChange = event => {
    this.setState({ searchTerm: event.target.value });
  };

  render() {
    return (
      < div className="search">
        < div>
          < h1>reactApp< /h1>
          < input onChange={this.handleSearchTermChange} value={this.state.searchTerm} type="text" placeholder="search" />
          {preload.shows.map(show => < ShowCard key={show.imdbID} {...show} />)})
        < /div>
      < /div>
    );
  }
}

export default Search;</pre>





</div>
<hr>


  </pre>
  <!--entire page pre-->
</div>


</div>
