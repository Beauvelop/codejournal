<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<aside><span class="rot90">{{state}}</span></aside>
<div class="angular-entry entry">
  <pre>
    <!-- pre for all -->
    <!-- <div >
  <input type="text" ng-model="data.msg">
  <h3>Msg: {{data.msg}}</h3>
</div>
<div ng-controller="firstCtrl" >
  <input type="text" ng-model="data.msg">
  <h3>Msg: {{data.msg}}</h3>
</div>
<div ng-controller="secondCtrl" >
  <input type="text" ng-model="data.msg">
  <h3>Msg: {{data.msg}}</h3>
</div> -->
<h4>A word about scope and modeling (scope inheritance)</h4>
I. This example shows modeling as property on an Obj. This is best practice and exploits the advantages of ang's scope inheritance.
TL;DR --> input in any field, entire scope gets updated.
<pre class="framed4 w50">
  < div > <span class="transGreen">//root scope</span>
    < input type="text" ng-model="<span class="ltblue">data<b class="ltred">.</b>msg</span>" >
    < h3>Msg: {{<span class="ltblue">data<b class="ltred">.</b>msg</span>}}< /h3 >
  < /div>

  < div ng-controller="firstCtrl" > <span class="transGreen">// 'firstCtrl'</span>
    < input type="text" ng-model="<span class="ltblue">data<b class="ltred">.</b>msg</span>" >
    < h3>Msg: {{<span class="ltblue">data<b class="ltred">.</b>msg</span>}}< /h3 >
  < /div>

  < div ng-controller="secondCtrl" > <span class="transGreen">// 'secondCtrl'</span>
    < input type="text" ng-model="<span class="ltblue">data<b class="ltred">.</b>msg</span>" >
    < h3>Msg: {{<span class="ltblue">data<b class="ltred">.</b>msg</span>}}< /h3 >
  < /div> </pre>
II. This example "breaks" the scope. The model in {{<em class="y">message</em>}} is essentially being overwritten.
TL;DR type in any box, only the model scoped to that input field is updated.
  <pre class="framed4 w50">
    < div > <span class="transGreen">//root scope</span>
      < input type="text" ng-model="<em class="y">message</em>" >
      < h3>Msg: {{<em class="y">message</em>}}< /h3 >
    < /div>

    < div ng-controller="firstCtrl" > <span class="transGreen">// 'firstCtrl'</span>
      < input type="text" ng-model="<em class="y">message</em>" >
      < h3>Msg: {{<em class="y">message</em>}}< /h3 >
    < /div>

    < div ng-controller="secondCtrl" > <span class="transGreen">// 'secondCtrl'</span>
      < input type="text" ng-model="<em class="y">message</em>" >
      < h3>Msg: {{<em class="y">message</em>}}< /h3 >
    < /div> </pre>

<pre class="prettyprint w60">
//myCtrl.js
var promise = $http.get('https://luckydogs.com/api/pets');

promise.then(function(results) {
  var results = results.data;
  var status = results.status;
})
</pre>

    <h4>A promise in it's most simple form</h4>
    <pre class="prettyprint w60">
    //myCtrl.js
    var promise = $http.get('https://luckydogs.com/api/pets');

    promise.then(function(results) {
      var results = results.data;
      var status = results.status;
    })
    </pre>
    <h4>In the $http injected service:</h4>
    <pre class="prettyprint w60">
this.getPets(function(puppy) {
  return({
    method: 'GET',
    url: 'https://luckydogs.com/api/pets'
  })
})
    </pre>
<div class="simple-frame">What does $http always return? <span class="dkorange med ans">A promise.</span>
<h4>Therefore, we are sending back to the controller <span class="dkorange med ans">A promise.</span></h4>
<hr>
A service-injected controller looks like this:
<pre class="prettyprint">
$scope.getPets(function() {
  var promise = myservice.getPets();  // myservice.getPets() returns a promise so, we put it on a var called promise.
  .then(function(data) {  // this callback takes in the entire response object.
    $scope.puppies = response.data.data;
  })
})

$scope.getPets(); //REMEMBER to invoke the function!</pre>
</div>
  </pre>

<hr>

<pre>
<h2 class="ltblue">Angular</h2>
<h4>A nice link for <a class="entry-link" target="_blank" href="https://vimeo.com/196481462">DM custom directives</a></h4>
<pre class="prettyprint w80">
  angular.module("myApp")
    .directive('mydirective', function() {
      return {
        restrict: 'AE',
        templateUrl: './dirSrc/mydirective.html',
        link: function(scope, element, attrs) {
          element.on('click', function() {
            console.log("You clicked my directive");
          })

        }
      }
    })

</pre>
<p class="caption">For Directives: by default this function's <em class="wh">scope</em> will be the same as this directive's $scope.
jqLite is only used inside of this link function. --but you can use a lot of jquery-type code here.

<em class="y">Element</em> in this function refers to the directive.html itself. So you have to be more specifice (i.e. with <span class="wh">.children()</span>)
in order to select the things inside.</p>

<p class="caption"></p>
</div><!--angular-entry END-->
