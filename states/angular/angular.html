<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<aside><span class="rot90">{{state}}</span></aside>
<div class="angular-entry entry">
  <pre>
    <!-- pre for all -->
<div class="plain-frame3"><h3>Custom Filter</h3>
  1. Inside the <em class="dkred">{ { } }</em> place data with a pipe, then filter name.
  <pre class="ltbg2 w50 ctr">
    < div ng-controller="firstCtrl" >
      < input type="text" ng-model="data.message">
      < h3 >Msg: {{data.message <b class="y">| charTotal</b>}}< /h3 >
    < / div></pre>
The pipe looks for a filtername, function is fired.

<span class="pastOlive">< script>charTotalFilter.js< / script>
</span><pre class="prettyprint w40">//charTotalFilter.js
angular.module("eggApp1")
  .filter("charTotal", function() {
    return function(text) {
      return text.split('').length;
    }
  })</pre>

</div>
<div class="plain-frame1"><h3 class="chtitle purp">A method on $scope</h3>
The ng-model is 'data.message'
It is bound to what is called (or returned) by this Fn call { { reversed) } }
<pre class="ltbg2 w50 ctr">
  < div ng-controller="firstCtrl" >
    < input type="text" ng-model="data.message">
    < h3 >Msg: {{reversed()}}< /h3 >
  < / div>
</pre>
<em>firstCtrl.js</em><pre class="prettyprint w50">angular.module("eggApp1")
  .controller("firstCtrl", function($scope, FacData) {
    $scope.data = FacData;
    $scope.reversed = function() {
      return $scope.data.message.split('').reverse().join('').toUpperCase();
    }
  })
// "This is reversed" entered
// return: DESREVER SI SIHT</pre>

In truth... This is the sloppy way:<pre class="ctr dkbg w50 sm">...
  return <span class="y">$scope.data.</span>message.split('').reverse().join('').toUpperCase();
...</pre>
Best practice is to <em>TRY</em> NOT to reference $scope inside of a function.
Instead we can simply send the input from < input > to the "{ {<em class="purp">reversed(<i class="ltred">data.message</i>)</em>} }" and then to the controller's method.
This then can just be <pre class="prettyprint w50">$scope.reversed = function(message) {
  return message.split('').reverse().join('').toUpperCase();
}</pre>NOTA BENE: <span class="ltred">DONT forget to put a parameter in the function signature in the controller! (cf. first line above)</span>

This function, then fires at:
<pre class="ltbg2 w50 ctr">
  < div ng-controller="firstCtrl" >
    < input type="text" ng-model="data.message">
    < h3 >Msg: {{ <i class="ltblue">reversed( <span class="ltred">data.message</span> )</i> }}< /h3 >
  < / div>
</pre>
</div>


<div class="simple-frame">
  <h4>A word about scope and modeling (scope inheritance)</h4>
I. This example shows modeling as property on an Obj. This is best practice and exploits the advantages of ang's scope inheritance.
TL;DR --> input in any field, entire scope gets updated.
<pre class="framed4 w50">
  < div > <span class="transGreen">//root scope</span>
    < input type="text" ng-model="<span class="ltblue">data<b class="ltred">.</b>msg</span>" >
    < h3>Msg: {{<span class="ltblue">data<b class="ltred">.</b>msg</span>}}< /h3 >
  < /div>

  < div ng-controller="firstCtrl" > <span class="transGreen">// 'firstCtrl'</span>
    < input type="text" ng-model="<span class="ltblue">data<b class="ltred">.</b>msg</span>" >
    < h3>Msg: {{<span class="ltblue">data<b class="ltred">.</b>msg</span>}}< /h3 >
  < /div>

  < div ng-controller="secondCtrl" > <span class="transGreen">// 'secondCtrl'</span>
    < input type="text" ng-model="<span class="ltblue">data<b class="ltred">.</b>msg</span>" >
    < h3>Msg: {{<span class="ltblue">data<b class="ltred">.</b>msg</span>}}< /h3 >
  < /div> </pre>

II. This example "breaks" the scope. The model in {{<em class="y">message</em>}} is essentially being overwritten.
TL;DR type in any box, only the model scoped to that input field is updated.
  <pre class="framed4 w50">
    < div > <span class="transGreen">//root scope</span>
      < input type="text" ng-model="<em class="y">message</em>" >
      < h3>Msg: {{<em class="y">message</em>}}< /h3 >
    < /div>

    < div ng-controller="firstCtrl" > <span class="transGreen">// 'firstCtrl'</span>
      < input type="text" ng-model="<em class="y">message</em>" >
      < h3>Msg: {{<em class="y">message</em>}}< /h3 >
    < /div>

    < div ng-controller="secondCtrl" > <span class="transGreen">// 'secondCtrl'</span>
      < input type="text" ng-model="<em class="y">message</em>" >
      < h3>Msg: {{<em class="y">message</em>}}< /h3 >
    < /div> </pre>
One more thing about the example I. above:
  <span class="med purp">firstCtrl & secondCtrl inherit from root. --Take the first div away and you have two siblings that don't update each other.</span>
III.<hr>
<h3 class="dkred">The problem:</h3> the 2 controllers don't share scope.

<h3 class="dkred">The solution: </h3> create a service (as a factory) that returns smth that references that prop on the object inside "{ {} }"
Then, feed that service to each controller
<img class="w50 shadn" src="./img/sharingScope1.png" alt="shared scope">

</div>
<pre class="prettyprint w60">
//myCtrl.js
var promise = $http.get('https://luckydogs.com/api/pets');

promise.then(function(results) {
  var results = results.data;
  var status = results.status;
})
</pre>

    <h4>A promise in it's most simple form</h4>
    <pre class="prettyprint w60">
    //myCtrl.js
    var promise = $http.get('https://luckydogs.com/api/pets');

    promise.then(function(results) {
      var results = results.data;
      var status = results.status;
    })
    </pre>
    <h4>In the $http injected service:</h4>
    <pre class="prettyprint w60">
this.getPets(function(puppy) {
  return({
    method: 'GET',
    url: 'https://luckydogs.com/api/pets'
  })
})
    </pre>
<div class="simple-frame">What does $http always return? <span class="dkorange med ans">A promise.</span>
<h4>Therefore, we are sending back to the controller <span class="dkorange med ans">A promise.</span></h4>
<hr>
The Fn accessing the promise looks like this in the  service-injected controller:
<pre class="prettyprint">
$scope.getPets(function() {
  var promise = myservice.getPets();  // myservice.getPets() returns a promise so, we put it on a var called promise.
  .then(function(data) {  // this callback takes in the entire response object.
    $scope.puppies = response.data.data;
  })
})

$scope.getPets(); //REMEMBER to invoke the function!</pre>
</div>
  </pre>

<hr>

<pre>
<h2 class="ltblue">Angular</h2>
<h4>A nice link for <a class="entry-link" target="_blank" href="https://vimeo.com/196481462">DM custom directives</a></h4>
<pre class="prettyprint w80">
  angular.module("myApp")
    .directive('mydirective', function() {
      return {
        restrict: 'AE',
        templateUrl: './dirSrc/mydirective.html',
        link: function(scope, element, attrs) {
          element.on('click', function() {
            console.log("You clicked my directive");
          })

        }
      }
    })

</pre>
<p class="caption">For Directives: by default this function's <em class="wh">scope</em> will be the same as this directive's $scope.
jqLite is only used inside of this link function. --but you can use a lot of jquery-type code here.

<em class="y">Element</em> in this function refers to the directive.html itself. So you have to be more specifice (i.e. with <span class="wh">.children()</span>)
in order to select the things inside.</p>

<p class="caption"></p>
</div><!--angular-entry END-->
