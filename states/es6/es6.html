<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<div class="es6-container">
  <aside><span class="rot90">{{state}}</span></aside>
  <div class="es6-entry entry">
  <!-- pre for entire page -->

  <!--
-->
<div class="simple-frame">
  <h1 class="chtitle thin softwhite">.filter() with ES6</h1>
<h3>First, it is important to realize that .filter() uses an expression as its body.<br />
So...
<pre class="prettyprint w50 ctr">cars.filter(ride => if(ride.style ==="luxury"){ return etc, etc...});</pre>
This is not going to work. "if" is, of course, a statement.
<br />.filter() needs a boolean, so...</h3>
<pre class="prettyprint w40 ctr">cars.filter(ride => ride.style == 'luxury');</pre>
<hr>
  <pre class="prettyprint w40 ctr">
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

    // Before...
    let es5Odds = numbers.filter(function(number) {
      return number % 2;
    });
    console.log(es5Odds);

    // After...
    let es6Odds = numbers.filter(number => number % 2);
    console.log(es6Odds);
</pre><br />
<p>Here we have an example of filter returning odds</p>
<pre class="prettyprint w50 ctr">const someNums = [1, 2, 3, 4];
 const oddsOfSomeNums = someNums.filter(nums => nums % 2)
// 1 3
</pre>
<br />


</div>
<hr>
<div class="simple-wine-frame thin softwhite"><h3 class="chtitle">Template & tagged strings</h3>

<h3 class="softwhite">A simple template string gives us this</h3>
<pre class="prettyprint w80 txt-left ctr">
let num1 = 1;
let bool = true;
let sentence = `Fewer things are more ${bool} than that ${num1} plus ${num1} equals ${num1 + num1}`;
console.log(sentence);
// Fewer things are more true than that 1 plus 1 equals 2
</pre>

<br /><h3 class="softwhite">Tagged strings</h3>
<h3>The component parts of this string are these strings and values concatenated:</h3>
<div class="dkbg w80 ctr ctrtxt brdr-w">
<code class="ltgreen"><span class="underline">Fewer things are more </span><span class="softsand">${bool}</span><span class="underline"> than that </span><span class="softsand">${num1}</span><span class="underline"> plus </span><span class="softsand">${num1}</span><span class="underline"> equals </span><span class="softsand">${num1 + num1}</span><span class="ltred">_</span></code>
</div><br />

<div class="chtitle softwhite med">Tagging strings gives us the power to "pre-process" the string. <br />
We create a function and 'call' that function with the template string as an argument that is <em>splayed</em> into it's component parts</div>
<pre class="prettyprint w80 ctr">
...

let tagged = function(strArr, ...vals) {
  console.log(strArr); // ["Fewer things are more ", " than that ", " plus ", " equals ", "",]
  // Note the very last empty "" at the end of the array.
  console.log( vals); // [true, 1, 1, 2]
};

tagged`Fewer things are more ${bool} than that ${num1} plus ${num1} equals ${num1 + num1}`;
</pre>
<hr>





</div>
<hr>
<div class="plain-frame1"><h3 class="chtitle softred">ES6 Object Enhancement & .repeat() method</h3>
<p>From ES5...</p>
<pre class="prettyprint w30 ctr">const captainKirk = {
  orders: function(order) {
    console.log(`${order}`)
  }
}


captainKirk.orders("Make it so.")
</pre>
<p>...to ES6</p>
<pre class="prettyprint w30 ctr">
const captainKirk = {
  orders(order) {  // Remove ": function"
    console.log(`${order} `.repeat(5))
  }
}

captainKirk.orders("Make it so.")
</pre>
<pre class="prettyprint w50 ctr">
// "Make it so. Make it so. Make it so. Make it so. Make it so. "
</pre>



</div>
<hr>
<div class="simple-frame2">
  <h2 class="chtitle">Spread Operators</h2><br />
  <h3 class="chtitle clean">Spread operators are used to expand an 'iterable object' when multiple items are expected.
  <br />They can be used in Fn calls, Parameter Lists, Array literals, Obj destructuring</h3>

<br /><pre class="prettyprint w60 ctr"> let goodNewsArray = ["John", "Luke", "Mark", "Matthew"];

let guys = function(john="john", paul="paul", george="george", ringo="ringo") {
  return `${john}, ${paul}, ${george} & ${ringo}.`
}

console.log(guys(...goodNewsArray)) // John, Luke, Mark & Matthew.
</pre>

<br /><br />
<h3 class="ivr clean">These are also REALLY useful for Array Literals:</h3>
<pre class="prettyprint ctr w60">
let beatlesArray = ["john", "paul", "george", "ringo"];

let charliesAngels = ["Kelly","Chris", "Sabrina", "Jill"];

let dateNight = [...beatlesArray, ...charliesAngels];

console.log(dateNight);
// (8) ["john", "paul", "george", "ringo", "Kelly", "Chris", "Sabrina", "Jill"]
</pre>
<br />
<hr>
<h3 class="chtitle thin">The "Rest Parameter"</h3>
The function below will join any limitless amount of parameters
the spread allows us to take an arbitrary number of params!

<pre class="prettyprint w50 ctr">  const joinUp = function(
    return words.join(' ');
  };
  console.log(joinUp('I', 'really', 'am', 'digging', 'es6!'));

  //I really am digging es6!
</pre><br />
<h3>A neat way to avoid the need for .split('');</h3>
<pre class="framed8 dkbg wh thin w50 ctr">function joiningFunk(<span class="orange">...words</span>) {     <span class="orange">// (rest parameter)</span>
  return words.join(' ');
}

var joined = joiningFunk("I", "want", "to", "join", "these", "words");

console.log(joined); <span class="ltgreen">// I want to join these words</span>
</pre>
<br />


</div>
<hr>
<div class="framed5"><h2 class="chtitle ivr thin">Default Parameters</h2>

<h2 class="thin">Default Parameter in a function declaration</h2><br />
<h4 class="paleY">At invocation if a param isn't passed--Function runs the default in the function signature...</h4>
  <pre class="prettyprint w50 linenums">
    function entree(fish = 'salmon') {
      console.log(`I think I'll have ${fish}`);
    }

    entree(); // I think I'll have the salmon

    entree('lobster'); // I think I'll have the lobster
  </pre>

<br /><br><h3 class="ctrtxt dkbg3 thin">running grunt es6 to create an es5 example gives us this very cool ternary condition</h3>

<h3 class="brdr-w">var fish = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'salmon';</h3>

<span class="sm ivr">if (<em>"there are more than zero args AND the first arg is NOT 'undefined', then run that first arg--Otherwise run it as 'salmon'..."</em>)</span>

<hr>
<h2 class="thin">Default Parameter in a function expression -- With a bonus feature!</h2><br />
<h3 class="chtitle paleY">We can exploit this feature to add multiple default params <br> default parameters are 'visible' to following or later parameters in the same parameter list</h3>
  <pre class="prettyprint linenums">
var seinfeld = function(food = 'pretzels', adjective = 'thirsty', catchphrase = `These ${food} are making me ${adjective}`) {
  console.log(catchphrase);
};

console.log(seinfeld());
//These pretzels are making me thirsty

console.log(seinfeld('meatballs'));
//These meatballs are making me thirsty

console.log(seinfeld(undefined, 'sick'));
//These pretzels are making me sick  (If one param is undefined, it will run the default)
    </pre>

</div>
<hr>
    <pre>
  <div class="simple-frame2">
    <h3 class="chtitle thin">Block-scopes with <b class="lg wh">let</b> & <b class="lg wh">const</b>: a simple illustration   <br><a target="_blank" href="https://code.tutsplus.com/courses/javascript-es6-fundamentals" class="sm">(c/o Dan Wellman)</a></h3>
    <h4>Let's take a look at <em class="ivr">let</em></h4>
    <pre class="prettyprint w30">
'use strict';
(function() {
  console.log(block);

  if (true) {
    let block = 'block';
  }
})();
    </pre>
    <h5>This, of course, returns: <span class="ans med ltred">Uncaught ReferenceError: block is not defined (or not declared!)</span>
  Why? (hint: "var" wouldn't throw an error--simply "undefined") --because <span class="ans med ltred">log calls block but let prevents it from being hoisted.</span></h5>


    <h6 class=" ctrtxt ivr">Even if the console.log(block) were <em>after</em> the if statement... it would still throw a ref error. </h6>

    <div class="dkbg3 w50 ctr brdr-w">
      <h5>Let has two features:<br />
    1) 'let' is to create scope to its containing block.<br />
    2) 'let' is not hoisted.<br />
    </h5>
      <h4>The temporal Dead-zone:</h4>
      <pre class="prettyprint w30 ctr">
'use strict';
(function() {

  if (true) {
    console.log(block);

    let block = 'block';
  }
})();
</pre>
      <h5>This, too, returns: <span class="med ltred">Uncaught ReferenceError: block is not defined (or not declared!)</span><br />
Everything inside the block prior to the 'let' declaration is known as the <span class="orange comfort">"Temporal Dead-zone"</span></h5>
    </div>
    <h4>Let's take a look at <em class="ivr">const</em></h4> It's read-only whose value can't be changed thru reassignment or redeclaration. Like let variables, they are not hoisted.
    <h4 class="chtitle">Though immutable, passing by reference to change an Object's value <em>DOES</em> work:</h4>
    <pre class="prettyprint w50 ctr">  let obj = {
    testColor: 'Blue'
  };

  const refToObject_C = obj;

  obj.testColor = 'Fuchsia';

  console.log(refToObject_C); // {testColor: "Fuchsia"}</pre>
    <h5 class="orange">As discussed in the "ecma" view of this site... passing by reference is using an "alias" and so, changes a value indirectly using that alias.</h5>
  </div>
  <hr>
  <div class="framed6">
    <h1 class="chtitle thin softwhite">.map() with ES6</h1>
    <h4>Note: <em class="ivr">implicit return</em></h4>
    <pre class="prettyprint w40 ctr">
var riceCrispies = [
  {character: "Snap!"},
  {character: "Crackle!"},
  {character: "Pop!"}
];

var cereal = riceCrispies.map(key => key.character);
// ["snap!", "Crackle!", "Pop!"]
</pre>

<pre class="prettyprint w50 ctr">var array = [1,2,3,4,5,6];
// es5
let es5Arr = array.map(function(element) { return  element + 1});
console.log("ES5", es5Arr); // [73, 72, 59, 34, 43]

// es6
var arr3 = [10, 20, 30, 40, 50];
let es6Arr = arr3.map(element => element + 1);
console.log("es6", es6Arr); // [73, 72, 59, 34, 43]</pre>

<div class="simple-frame">
<h3>.map() with array of objects is very straightforward:</h3>
  <pre class="prettyprint w50">var people = [
  {name: "Sue",age: 23},
  {name: "Kim",age: 13},
  {name: "Joe",age: 21}
];

var ageArr = people.map(function(person){
  return person.age;
});
  // [23,13,21]</pre>
<h3>And in es6</h3>
  <pre class="prettyprint w40">var ageArr = people.map(person => person.age;)</pre>
</div>
  </div>
  <hr>
  <div class="simple-frame2">
    <h3 class="chtitle">The spread operator: ES6</h3> All you need is <span class="y">...</span> then <i class="y">varName</i>
    <pre class="prettyprint w80 col-2">function addItems(a, b, c) {

  if (typeof a === 'string') {
    console.log(`${a} ${b} ${c}`);

  } else if (typeof a === 'number') {
    console.log(a + b + c);
  }

}

var nums = [3, 4, 7];
//instead of addItems(nums[0], nums[1], nums[2]);
addItems(...nums); // 14

var fruit = ['apple', 'grape', 'pear', 'kiwi'];
// instead of addItems(nums[0], nums[1], nums[2]);
addItems(...fruit); // apple grape pear

// You can also join the arrays

var peanutButter = ["plain", "chunky", "organic"];
var jelly = ["strawberry", "apricot", "grape"];

var pbNj = [...peanutButter, ...jelly];

console.log(pbNj);
// ["plain", "chunky", "organic", "strawberry", "apricot", "grape"]
</pre>

  </div>
  <div class="framed5">
    <h3 class="chtitle ivr">The power of Object.assign()</h3>
    <pre class="prettyprint">
  var myStuff = { name: 'myStuff', a: 3, b: "puppies", c: 18, d: "babies", e: false, f: -1, g: "worms" };

function typeGroomer(input, test) {
  for (let prop in input) {
    if (typeof input[prop] !== test) {
      delete input[prop];
      var groomed = Object.assign({}, input);
    }
  }
  console.log(groomed);
  return groomed;
}
// let onlyNums =typeGroomer(myStuff, "number");
// let onlyBools = typeGroomer(myStuff, "boolean");
let onlyStrings =typeGroomer(myStuff, "string");
</pre> There is much more to Object.assign();
    <div class="dkbg pastOlive w40">
      <a class="sand" target="_blank" href="https://youtu.be/vM7Tif98Dlo">Here's a helpful link</a>
      <a class="sand" target="_blank" href="https://googlechrome.github.io/samples/object-assign-es6/">AND here</a>

    </div>
  </div>
  <div class="slate-skyblue-fr">
    <h3 class="chtitle">Template Literals</h3>
    <pre class="prettyprint w60">
const italian = {
  name: "Italians",
  meal: "pasta",
  pan: "pot",
  oil: "sesame",
  info: function() {
    console.log(`${this.name} cook ${this.meal} in a ${this.pan} with ${this.oil} oil.`);
  }
}
american.info(); // Americans cook chicken in a frying pan with corn oil.
</pre>
    <hr>
    <h3 class="chtitle underline">ES6 string methods:</h3>
    <h4 class="pastY">startsWith() endsWith() includes()</h4>
    <pre class="prettyprint w40">  italian.info().includes('cook'); // true
  italian.info().startsWith('cook'); // false
  italian.info().endsWith('oil.'); // true
</pre>

  </div>
  <div class="simple-frame2">
    <h2 class="ctrtxt">for of loops</h2> Plain es5 iteration:
    <pre class="prettyprint w40">
  var car = {
    color: "red",
    wheels: 4,
    transmission: "manual",
    domestic: false
  }

  for (var prop in car) {
    console.log(prop);
  } // color wheels transmission domestic
</pre>
    <em>for in</em> is for objects --but if you <b>must</b> use 'for of', this will work.
    <pre class="prettyprint w40">
  for (var prop of Object.keys(car)) {
    console.log(prop);
  }
</pre> for of is built for arrays
    <pre class="prettyprint w60">
  var carArr = [{color: "red"}, { wheels: 4}, {transmission: "manual"}, {domestic: false}];

  for (prop of carArr) {
    console.log(prop);
  }
  <img class="w20" src="./img/forof.jpg" alt="for of loop">
</pre>

  </div>
  <hr>
  <div class="framed3">
    <h2 class="pastY ctrtxt">Object destructuring & Array destructuring</h2> Object Destructuring:
    <pre class="prettyprint w40">
  var user = {
    name: "Alex",
    age: 34,
    job: "Farmer"
  };

  var {name, age, job} = user;
  console.log(name);
  console.log(age);
  console.log(job);
</pre> This is also useful with a function
    <pre class="prettyprint w40">
  function getTree() {
    return {
      residents: ['squirrel', 'robin family'],
      foliage: "leaves",
      branches: 14,
      age: 25
    }
  }

var {residents, foliage, brances, age} = getTree();
console.log(getTree());
// Object {
//  residents: Array(2),
//  foliage: "leaves",
//  branches: 14,
//  age: 25
// }
</pre> Array destructuring:
    <pre class="prettyprint w40">
  var arr = ["Alex", 34, "Farmer"];

  //old way...
  // var name = arr[0];
  // var age = arr[1];
  // var job = arr[2];

  //ES6
  var [name, age, job] = arr;
  console.log(job);
</pre>

  </div>
  <hr>
  <div class="slate-skyblue-fr">
    <h3 class="wh ctrtxt">Arrow Functions ("fat-arrow")</h3>

    <div class="brdr-w dkbg ctr ctrtxt">
      Let's remind ourselves of the brevity that arrow funcs allow for:

      <pre class="prettyprint w40 txt-left ctr">const emote = (icon) => console.log(`${icon}`);
  emote("🤓");
  // or... const emote = (icon) => console.log(icon);
  // 🤓</pre> Let's say I set up a func that takes two args:

      <pre class="prettyprint w40 txt-left ctr">function serve(iceCream, flavor) {
    iceCream(flavor);
  }</pre> I see in the body of the function that <code>serve()</code> is a function and it will subsequently take arg 2 (in the function signature). I have to call this "serve()" with two args. The clumsy way is thus:

      <code>serve(<span class="paleY underline">function defineFlavor(fruit) {console.log(fruit)}</span><sup class="wh">1</sup>, <span class="lightgreen">"🍋"</span><sup class="wh">2</sup>);</code> All of the extra text in arg <sup class="wh">1</sup>      simply becomes "iceCream" in the function serve() above it. So it's MUCH, much simpler to remove all of that and use an anonymous function instead of all of that mess. Let's clean it up:

      <pre class="prettyprint w40">serve((fruit) => console.log(fruit), "🍋"); // 🍋</pre>
      <pre class="prettyprint w40">serve((fruit) => console.log(fruit), "🍓"); // 🍓</pre>
<hr>

<div class="simple-wine-frame w60 ctr txt-left">
<pre class="prettyprint w40 txt-left ctr">var order = "Phasers on stun.";
var issueCommand = (order) => console.log(order);
var test = issueCommand(order);
// Phasers on stun.
</pre>
<pre class="prettyprint w40 txt-left ctr">
var issueCommand = (order) => console.log(order);
issueCommand("Warp factor 2!");
// Warp factor 2!
</pre>
<pre class="prettyprint w40 txt-left ctr">
var orders = "Make it so.";
var issueCommand = orders => orders; //Bare essence of ES6 Fn
var example = issueCommand(orders);
console.log(example);
// Make it so.
</pre>
<p>The final ES6 funk has no return statement <em>("Implicit return")</em><br />It has no "{}" or "()"</p>

</div>
    </div>
    <hr> The following works in ES5:
    <pre class="prettyprint w40">
var people = [
  {name: "Sue",age: 23},
  {name: "Kim",age: 13},
  {name: "Joe",age: 21}
];

var ageArr = people.map(function(person){
  return person.age;
});
    // [23,13,21]
</pre> But in ES6, it's much cleaner code.
    <span class="y">IF you only have ONE argument</span>, don't use braces<br /> ALSO. <span class="y">If you are only returning one thing</span> and not doing other things in the Fn.
    <h3 class="ltred">GET RID OF the return statement and the "{}"</h3>
    <pre class="prettyprint w40">var ageArr = people.map(person => person.age;)</pre> Here is a promise callback using an Arrow Function.
    <span class="ivr"><em>Old way:</em></span>
    <pre class="prettyprint w40">
$http.get(function('/api/people')
.then(function(data) {
  return res.data;
})</pre>
    <span class="mango"><em>New ES6 way:</em></span>
    <pre class="prettyprint w40">
$http.get(function('/api/people')
.then(data => res.data)</pre> Don't use arrow functions as method on an object! 'this' breaks everything!
    <a href="https://vimeo.com/216583233" target="_blank">dm link about arrow functions and this</a>
  </div>
  <hr>
  <div class="plain-frame3">
    <h3 class="w60">The "let" keyword.
  var has 2 kinds of scope. Global and Lexical (or functional) scope.</h3>
    <span class="ivr">This code doesn't throw an error in es5.</span>
    <pre class="ctr prettyprint w40">
  var gimmeSum = function(sum) {
    if(sum) {
      var total = sum + 3;
    }
    return total;
  }
  gimmeSum(7)
  // 10</pre>
    <h3 class="caption">However, let variables are not implicity hoisted</h3>
    <pre class="ctr prettyprint w40">var gimmeSum = function(sum) {
    if(sum) {
      let total= sum + 3;
    }
    return total;
  }
  gimmeSum(7) // undefined b/c 'total' is block-scope
  </pre>
    <h3 class="caption">This can be solved by:</h3>
    <pre class="ctr prettyprint w20">if(sum) {
    let total = sum + total;
    return total;
  }</pre>
    <h3><em class="wh">let</em>'s entire purpose is: block-scoping</h3>

  </div>

</div>
<!-- ES6 entry div end -->
</pre>
<!-- end of pre for entire page -->



</div>
