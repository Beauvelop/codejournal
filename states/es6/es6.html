<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<div class="es6-container">
  <aside>
    <span class="rot90">{{state}}</span>
  </aside>
  <div class="es6-entry entry">
    <!-- pre for entire page -->
    <!-- FIXME: this needs an edit -->
    <!-- <div class="framed3">
      <h1>What you should know about es6's this in arrow functions</h1>
      <p>The way arrow functions work in es6 functions needs close attention:</p>
      <pre class="prettyprint w50 ctr">
    var control = {
      var self = this;
      btn.addEventListener('click', function() {
        self.doSomething(...);
      })
    }
  </pre>


      <p></p>
      <pre class="prettyprint w50 ctr"></pre>
    </div>
 -->
    <div class="framed2">
      <h1>A bit about arrows & this vs es5 funks & this</h1>
      <p>The
        <em>this</em> binding works just fine, here.</p>
      <pre class="prettyprint w50 ctr">const teddyES5 = {
    name: "Teddy",
    kind: "bear",
    printDesc: function() {
        console.log(`${this.name} is a ${this.kind}`)
    }
}
teddyES5.printDesc(); // Teddy is a bear.
</pre>
      <p>We run into a problem with es6 methods because => Funks don't bind theirown
        <em>this</em> value.</p>
      <pre class="prettyprint w50 ctr">
const teddyES6 = {
    name: "Teddy",
    kind: "bear",
    printDesc: () => {
        console.log(`${this.name} is a ${this.kind}`)
    }
}
teddyES6.printDesc(); // "ERR: can't read name of undefined"
// => Fn doesn't bind itsown 'this' value. it uses window --so using es6 in a method sucks.
</pre>
      <p>HOWEVER... if we use, say, an => wrapped in an es5...
        <em>this</em> will work.
        <br> Take a look at
        <em>this.name</em> below...</p>
      <pre class="prettyprint w50 ctr">

const teddyCombo = {
    name: "Teddy",
    kind: "bear",
    favFoods: ["salmon", "humans"],
    printFood: function() {
        this.favFoods.forEach(item => console.log(this.name + ` ${item}`));
    }
}
teddyCombo.printFood(); // (this.name reference is legit!)
/*
Teddy salmon
app.js:77 Teddy humans
*/
</pre>
    </div>

    <hr>

    <div class="framed2 wh">
      <h1 class="chtitle softblue thin">Object.defineProperty(
        <span class="wh">object</span>)</h1>
      <div class="">
        <pre class="prettyprint w50 ctr">var vwBug = {
     name: 'Buggy',
     speed: 45,
     color: 'orange',
   };</pre>
        <p>Here, I'll add a "print task" with Obj.defineProperty(); NOTE: the props of this ONLY EFFECT THIS PROPERTY!</p>
        <pre class="prettyprint w50 ctr">Object.defineProperty(vwBug, 'printDetails', {
     value: function() {
       console.log(
         `Name ${this.name}, Speed: ${this.speed}, Color:  ${this.color}`
       );
     },
     writable: true, // whether changeable
     enumerable: false, // whether Obj.keys()|| loops can iterate...
     configurable: true, // whether settings are changeable
   });
   
   vwBug.printDetails(); // Name Buggy, Speed: 45, Color: orange
   </pre>

        <p>writable: false --You can't alter or over-write this property accidentally.</p>
        <pre class="prettyprint w40 ctr">
   var keys = Object.keys(vwBug);
   console.log(keys); //[ 'name', 'topMPH', 'color', 'printDetails' ]</pre> /* --Let's say I want to loop thru the props of this vwBug, but I want it to look clean --I don't want this helper
        method "printDetails" in the list... Then, I simply set enumerable to "false" */
        <pre class="prettyprint w40 ctr">
   // (after "enumerable: false"...)
   console.log(keys); //[ 'name', 'topMPH', 'color' ]
   </pre>
        <p>configurable is set to true if these props are to be changed further down the code. "false" locks this property.</p>
      </div>
      <hr class="w40 ctr">
      <h4 class="wh">We have a simple object returning a useful string to place onto an element.</h4>
      <pre class="prettyprint ctr w60">
 var colorHSL = {
   hue: 180,
   saturation: 50,
   lightness: 50,
   output: function() {
     var colorString =  "color: hsl(" + this.hue + ", " + this.saturation + "%, " + this.lightness + "%);";
     console.log(colorString);
   }
 }
 
 colorHSL.output();
 
 // color: hsl(180, 50%, 50%);
 </pre>
      <span class="med wh">I can create further properties on this object using
        <em>Object.defineProperty()</em> passing in 3 arguments.</span>
      <ol class="w40 condensed-list">
        <li>the modified object.</li>
        <li>the name of the new property.</li>
        <li>a javascript object which I can configure.
      </ol>
      <pre class="prettyprint ctr w40">
     Object.defineProperty(colorHSL, "modSat", {
       value: function(amount) {
         this.saturation += amount;
         this.output();
       }
     })
 
     colorHSL.modSat(30);
     // color: hsl(180, 80%, 50%);
 
     Object.defineProperty(colorHSL, "modHue", {
       value: function(amount) {
         this.hue += amount;
         this.output();
       }
     })
 
     colorHSL.modHue(50);
     // color: hsl(230, 80%, 50%);
     Object.defineProperty(colorHSL, "modLight", {
       value: function(amount) {
         this.lightness += amount;
         this.output();
       }
     })
 
     colorHSL.modLight(-20);
     // color: hsl(230, 80%, 30%);
   </pre>
      <p>Very nice. I can add properties/methods to the object to modify it using the "value:" keyword... Now let's try this
        with a property...giving colorHSL's hue a default of 90;</p>
      <pre class="framed6 w50">Object.defineProperty(colorHSL, "modHue", {
   value: 90
 })
 
 <span>Now let's update it...</span>
 colorHSL.modHue(-50);
 console.log(colorHSL.output());
 </pre>

      <h3>Let's add another property to our colorHSL object. We will make this a default</h3>
      <h3>._hue (by convention, an "_" may be prepended)</h3>
      <pre class="framed6 w60">
 Object.defineProperty(colorHSL, "_hue", {
   value: 90
 })
 
 colorHSL._hue = 0;   // THIS line throws a TypeError!
 <h3 class="ltgreen">"You cannot assign '0' to read-only property"</h3>
 console.log(colorHSL._hue);
 
 <h4 class="paleY ctr w50">Here we have one very useful feature of .defineProperty();
 
 "_hue" will never be changed --unless, a flag "writable: true" is added to the object</h4>
 
 Object.defineProperty(colorHSL, "_hue", {
  value: 90,
  <span class="mango">writable: true</span>
 })
 
 <h4 class="paleY ctr w50">We, now, can modify and return the new value</h4>
 
 colorHSL._hue = 200;
 console.log(colorHSL._hue);<span class="ltgreen thin">  // 200</span>
 </pre>
      <p>(enumerable: true --is also a possible boolean flag)</p>
      <hr>
      <h2 class="chtitle thin">The power of getters & setters using .defineProperty()</h2>

      <h4 class="wh">HSL colors in CSS have a range of values within which the rule applies. hue: 0 - 360 & the others 0-100%. Let's start
        from scratch setting each property at "0"</h4>

      <pre class="prettyprint ctr w60">var colorHSL = {
   _hue: 0,
   _saturation: 0,
   _lightness: 0,
   output: function() {
     var colorString=  "color: hsl(" + this._hue + ", " + this._saturation + "%, " + this._lightness + "%);";
     console.log(colorString);
   }
 }
 colorHSL.output();
 </pre>

      <h4 class="ctr ltgreen">
        <span class="mango">This returns: </span>color: hsl(0, 0%, 0%);</h4>

      <p class="softsand">Now instead of
        <em>"value:"</em> I use
        <span class="paleY">get:</span> &
        <span class="paleY">set:</span> to modify the property.</p>
      <pre class="framed6 ctr w50">Object.defineProperty(colorHSL, "hue", {
    get: function() {
      console.log(this._hue);
      return this._hue;
    },
 <span class="wh sm thin">This "get:" method is clear enough. It will always reach into coloHSL and return the _hue property. <br>
 However, with<code class="dkorange">set</code>, I must be careful to respect the bounds of acceptable CSS hsl values.
 I allow for<code class="dkorange">set</code> to accept an argument<code class="ltgreen">input</code>
 But, I set a "filter" of sorts --only accepting a new input that meets a condition...</span>
    set: function(<span class="ltgreen">input</span>) {
      if <span class="dkorange">(input>=0 && input <= 360)</span> {
        this._hue = input;
        console.log(`New Hue value: ${this._hue}`);
      }
    }
  })
 <span class="wh sm thin">... if the new input doesn't meet the condition, a new value is not set and the default colorHSL._hue returns
 <span class="ltgreen">// color: hsl(0, 0%, 0%);</span>
 
 ... if the new input meets the condition, a new value is sent to colorHSL._hue
 <span class="ltgreen">// New Hue value: 200</span>
 
 --finally, a sanity check;
 <code class="wh">colorHSL.output();</code>
 <span class="ltgreen">// color: hsl(200, 0%, 0%);</span>
 </span>
 </pre>
      <h3 class="ltgreen med">Proof of concept available:
        <a href="https://codepen.io/beau_dev/full/brNZXB/"> here</a>
      </h3>
      <p>Completed .js code here</p>
      <pre class="prettyprint linenums w50">
 'use strict';
 
 var centerDiv = document.querySelector(".hsl-div");
 var enterBtn = document.querySelector(".enter-btn");
 var outputTxt =document.querySelector(".output-code");
 var inputHue =document.querySelector(".input-hue");
 var inputSat =document.querySelector(".input-sat");
 var inputLight =document.querySelector(".input-light");
 
 
 
 // HSL obj containing defaults
 var colorHSL = {
   _hue: 50,
   _saturation: 50,
   _lightness: 50,
   output: function() {
     var colorString=  `hsl(${this._hue}, ${this._saturation}%, ${this._lightness}%)`;
     return colorString;
   }
 }
 
 Object.defineProperty(colorHSL, "hue", {
   get: function() {
     console.log(this._hue);
     return this._hue;
   },
   set: function(input) {
     if (input>=0 && input <= 360) {
       this._hue = input;
     }
   }
 })
 
  Object.defineProperty(colorHSL, "saturation", {
    get: function() {
      console.log(this._saturation);
      return this._saturation;
    },
    set: function(input) {
      if(input>=0 && input <= 100) {
        this._saturation = input;
      }
    }
  })
 
  Object.defineProperty(colorHSL, "lightness", {
    get: function() {
      return this._lightness;
    },
    set: function(input) {
      if(input>=0 && input <= 100) {
        this._lightness = input;
      }
    }
  })
 
 
 /*----------------click event ------------------*/
 enterBtn.addEventListener('click', () => {
   colorHSL.hue = inputHue.value;
   colorHSL.lightness = inputLight.value;
   colorHSL.saturation = inputSat.value;
   let result = colorHSL.output();
 
   centerDiv.style.backgroundColor = result;
   outputTxt.textContent = result;
 })</pre>
    </div>

    <hr>
    <div class="brdr-w dkbg ctr softsand">
      <h1 class="chtitle thin">Array.from(): new in 2015</h1>
      <h3 class="wh">
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">MDN</a> has all you need to know about Array.from() but it needs some examples to solidify understanding.</h3>
      <br>

      <p>First, the old way...</p>
      <pre class="prettyprint w60 ctr">
var myArray = ["Clooney", "Pitt", "Pacino", "Newman", "Pattinson", "Gadot", "Johansson", "Jennifer Lawrence", "Felicity Jones", "Robin Wright"];

function sortIterate(arr) {
  var nuArr = [];
  myArray.map(function(item) {
    nuArr.push(item)
  })
  return nuArr.sort();
}

sortIterate(myArray)
</pre>

      <p>Now, in 2015's ES6 a much more concise method.</p>

      <pre class="prettyprint w30 ctr">
function sortIterateEs6(arr) {
  const args = Array.from(arr);
  return args.sort();
  
}

sortIterateEs6(myArray)
</pre>


      <h2 class="thin ghost">There is also a fancy-schmancy number generator at the bottom of the docs, exploiting an undefined argument in the
        syntax...</h2>

      <pre class="prettyprint w30 ctr brdr-w">
// Using an arrow function as the map function to
// manipulate the elements

Array.from([1, 2, 3], x => x + x);      
// [2, 4, 6]

// Generate a sequence of numbers
// Since the array is initialized with `undefined` on each position,
// the value of `v` below will be `undefined`
Array.from({length: 5}, (v, i) => i);
// [0, 1, 2, 3, 4]
</pre>
    </div>
    <hr>
    <div class="framed4">
      <h1 class="chtitle">Object Destructuring</h1>
      <br>
      <h2 class="chtitle wh thin">Simply putting values onto keys as variables is dead-easy</h2>
      <h3>I have an object</h3>
      <pre class="dkbg2 w30 ctr">let person =
  {
    first: 'jill',
    last: "williamson",
    gender: 'female',
    favFood: ['Italian', 'Eastern', 'Doritos'],
    city: "New Haven",
  };</pre>
      <p>I place each key onto a var thus:</p>
      <br>
      <code class="med wh dkbg">let {first, last, gender, favFood, city} = person;</code>
      <br>
      <br>
      <br>
      <pre class="prettyprint w40 ctr">
console.log(first) // jill
console.log(last) // williamson
console.log(gender) // female
console.log(favFood) // ['Italian', 'Eastern', 'Doritos']
console.log(city) // New Haven
   </pre>
      <br>
      <br>
      <pre class="prettyprint w30 ctr">console.log(person);
/*
  {first: 'jill',
  last: 'williamson',
  gender: 'female',
  favFood: [ 'Korean', 'Indian', 'Snack' ],
  city: 'New Haven' }
  */</pre>
      <br>
      <p>I can add a prop to this object with a default value:</p>
      <br>
      <code class="med wh dkbg">let {first, last, gender, favFood, city, friend="Lucy"} = person;</code>
      <br>
      <br>
      <p>This will render the exact same thing</p>
      <pre class="prettyprint w30 ctr">console.log(person);
  /*
    {first: 'jill',
    last: 'williamson',
    gender: 'female',
    favFood: [ 'Korean', 'Indian', 'Snack' ],
    city: 'New Haven' }
  */</pre>
      <br>
      <p>However, logging the var "friend" yields...</p>
      <pre class="prettyprint w30 ctr">console.log(friend) // Lucy</pre>
      <hr class="w40">
      <p>Let's verify what is happening here by iterating over an object's props after destructuring & declaring a default prop:</p>
      <br>
      <pre class="prettyprint w40 ctr">
  var dog = {
    name: "Barky",
    ears: "Long"
  };
  
  let {name, ears, tail= "Wagging"}= dog;
  
  let i = 1;
  for(var prop in dog) {
    console.log(`Prop${i}: ${[prop]}`)
    i++;
  }</pre>
      <p>this returns:</p>
      <pre class="prettyprint w20 ctr">// Prop1: name
// Prop2: ears</pre>
      <br>
      <p>The es5 way of using dot notation cannot access the newly assigned prop --because it isn't a prop
        <em>per se</em> it's a variable.</p>
      <pre class="prettyprint w50 ctr">console.log(dog.name) //female
console.log(gender) //female

console.log(person.friend) //undefined
console.log(friend) //Lucy
  </pre>
      <br>
      <h2 class="clean">To be clear, object destructuring is the same as declaring vars with these keynames and auto-generating their values
        from the
        <code class="paleY">object<em class="orange">.key</em></code>I do this to avoid writing the following laborious code:</h2>
      <br>
      <pre class="prettyprint w20 ctr">...
var first = person.first;
var last = person.last;
...</pre>
      <hr class="w40">
      <p>--Let's say I don't like those prop-names (as variables) in the person object.
        <br> All we need to do is swap the prop names (of original object) for new variable names: </p>
      <pre class="prettyprint w60 ctr">let {name: firstName, ears: earlength, tailStatus= "Wagging"}= dog;
  console.log(firstName) // Barky
  console.log(earlength) // Long
  console.log(tailStatus) // Wagging
  </pre>
      <hr>
      <h2>
        <strong class="softwhite">Look Closely:</strong> I've done 3 important es6 things in one line of code!</h2>
      <pre class="shadn w60 softwhite">
  1) Destructure this object & simultaneously
  2) Exchange those prop names in the place of new var names & and simultaneously...
  3) Add another property with a value if we'd like.</pre>

      <h2>Yet another aspect to destructuring is multiple assignation: assigning to many variables one-single value.</h2>
      <br>
      <pre class="prettyprint w40 ctr">
var {number:age, number:friendsTotal, number:bankbalance} = {number: 0};
// console.log(age) // 0
// console.log(friendsTotal) // 0
// console.log(bankbalance) // 0
</pre>

      <h2>Destructuring arrays ALSO works!</h2>
      <pre class="ltbg2 med shadn w40 ctr">
    let dessert = ["🍪", "🍩", "🍰"];
    let [choice1, choice2, choice3] = dessert;
    
    console.log(choice1) // 🍪
    console.log(choice2) // 🍩
    console.log(choice3) // 🍰
</pre>
    </div>
    <hr>
    <div class="simple-frame">
      <h1 class="chtitle wh thin">Extending a class is easy.</h1>
      <p>Passengers are on the next shuttle to Boston. Many Commuters have luggage, some dont.</p>
      <br />
      <pre class="prettyprint w50 ctr">class Passenger {
  constructor(id, seatNum){
    this.id = id;
    this.seatNum = seatNum
  }
  printTicket() {
    return`Passenger ${this.id} is ready to board.`;
  }
  getInfo() {
    return`Passenger ${this.id} is in seat# ${this.seatNum}`;
  }
}

const johnathanPie = new Passenger(153, "F-18");
console.log(johnathanPie.getInfo())
</pre>
      <br>
      <p>Here, we have two methods that deliver the args sent in to the definition of
        <code>johnathanPie</code>
        <br /> Below, we will extend the Passenger to determine luggage description & call it Commuter.
        <br /> We create a constructor with the params of the parent class
        <em class="ltred">PLUS a "baggage" param</em>.
        <br /> We then call super with parent params and place the new luggage var on this:
        <code>this.baggage = baggage;</code>
      </p>
      <hr>
      <pre class="prettyprint w50 ctr">class Passenger {
  constructor(id, seatNum){
    this.id = id;
    this.seatNum = seatNum
  }
  printTicket() {
    return`Passenger ${this.id} is ready to board.`;
  }
  getInfo() {
    return`Passenger ${this.id} is in seat# ${this.seatNum}`;
  }
}
class Commuter extends Passenger{
  constructor(id, seatNum, luggage) {
    super(id, seatNum)
    this.luggage = luggage;
    console.log(this.luggage)
  }
}

const johnathanPie = new Commuter(153, "F-18", "Samsonite");
console.log(johnathanPie.getInfo())

// Samsonite
// Passenger 153 is in seat# F-18
</pre>
      <hr>
      <p>We can conditionally render whether Commuters have a bag by OVERRIDING the getInfo method in this extended Commuter
        class...
      </p>
      <pre class="prettyprint w20 ctr">hasBags() {
  return !!this.luggage;
}</pre>
      <p>This is an easy way to return a boolean from a string that has been coerced.
        <br /> We put it to good use in an if clause by calling it...</p>
      <pre class="dkbg w50 ctr codePro">class Passenger {
  constructor(id, seatNum){
    this.id = id;
    this.seatNum = seatNum
  }
  printTicket() {
    return`Passenger ${this.id} is ready to board.`;
  }
  getInfo() {
    return`Passenger ${this.id} is in seat# ${this.seatNum}`;
  }
}

class Commuter extends Passenger{
  constructor(id, seatNum, <span class="paleY">luggage</span>) {
    super(id, seatNum)
    <span class="paleY">this.luggage = luggage;</span>
  }
  hasBags() {
    return !!this.luggage;
  }
  getInfo() {
    var details = super.getInfo();

    <span class="paleY">if(this.hasBags()){
      details += ` Bag description: ${this.luggage}`
    }</span>

    return details;
  }
}

const johnathanPie = new Commuter(153, "F-18", <span class="paleY">"Guitar Case"</span>);
console.log(johnathanPie.getInfo())

const sueKim = new Commuter(231, "B-17")
console.log(sueKim.getInfo())
<span class="ltgreen">
// Passenger 153 is in seat# F-18 Bag description: Guitar Case
// Passenger 231 is in seat# B-17
</span>
</pre>
      <p>SueKim has no bags...</p>
      <hr />
      <h3>One more for good measure:
        <em class="dkblue">Checking for VIP status</em>
      </h3>
      <pre class="prettyprint w50 ctr">...

  class Vip extends Passenger {
    constructor(id, seatNum, status) {
      super(id, seatNum);
      this.status = status;
    }
  hasStatus() {
    return !!this.status;
  }
    getInfo() {
      let vipDetails = super.getInfo();
      if(this.hasStatus()) {
        vipDetails = `Passenger ${this.id} in ${this.seatNum} is a ${this.status} VIP.`
      }
      return vipDetails;
    }
  }

  const johnathanPie = new Vip(153, "F-18", "Gold");
  console.log(johnathanPie.getInfo())

  const sueKim = new Vip(231, "B-17", "Platinum")
  console.log(sueKim.getInfo())

// "Passenger 153 in F-18 is a Gold VIP."
// "Passenger 231 in B-17 is a Platinum VIP."
</pre>
      <hr>
      <h2 class="chtitle ctr wh">Hue, Saturation, Lightness, Alpha Machine</h2>
      <pre class="softblue-bg ctr brdr-w w50">

  class Hsl {
    constructor(name = "white", hue = null, sat = null, light = null) {
      this.name = name;
      this.hue = hue;
      this.sat = sat;
      this.light = light;
    }
    getInfo() {
      return `The color's name is ${this.name}`;
    }

    getRule() {
      return `${this.hue}, ${this.sat}%, ${this.light}`;
    }
  }

  class Hsla extends Hsl {

    constructor(name, hue, sat, light, alpha) {
      super(name, hue, sat, light);
      this.alpha = alpha;
    }

    hasAlpha() {
      return !!this.alpha;
    }

    getRule() {
    var rule = super.getRule();
    var a = '';

    if (this.hasAlpha()) {
      rule = `${rule},${this.alpha}`;
      a = "a";
    }

    return `hsl${a}(${rule})`;
  }

  }

  const background = new Hsla("slateRed",0, 15, 23 )
  console.log(background.getRule())
  <span class="ltgreen">
  // "hsl(0, 15%, 23)"
  </span>

  const txtColor = new Hsla("Blood", 0, 65, 30, 3);
  console.log(txtColor.getRule());
<span class="ltgreen">
//  hsla(0, 65%, 30,3)
</span>
</pre>
    </div>
    <hr>
    <div class="framed8">
      <h2 class="chtitle dkblue">CHALLENGE: this needs to be refactored.</h2>
      <h3 class="paleY"> We have a method that doesn't use es6 syntax, variables that are created needlessly and an arrow function that is too
        verbose.
      </h3>
      <pre class="prettyprint w40 ctr">const user = {
    name: "Andrew",
    cities: ["Houston", "Paris", "Los Angeles"],
    printPlacesLived: function () {
       const nuArray = this.cities.map((city)=> {
            return this.name + ` lived in ${city}`;
       });
       return nuArray;
    }
}</pre>
      <h2 class="chtitle dkblue">SOLUTION:</h2>
      <div class="ans">
        <pre class="prettyprint ctr">const user = {
    name: "Andrew",
    cities: ["Houston", "Paris", "Los Angeles"],
    printPlacesLived () {
       return this.cities.map((city)=> this.name + ` lived in ${city}`);
    }
}</pre>
      </div>
    </div>
    <hr>


    <div class="simple-frame">
      <h1 class="chtitle thin softwhite">.filter() with ES6</h1>
      <h3>First, it is important to realize that .filter() uses an expression as its body.
        <br /> So...
        <pre class="prettyprint w50 ctr">cars.filter(ride => if(ride.style ==="luxury"){ return etc, etc...});</pre> This is not going to work. "if" is, of course, a statement.
        <br />.filter() needs a boolean, so...</h3>
      <pre class="prettyprint w40 ctr">cars.filter(ride => ride.style == 'luxury');</pre>
      <hr>
      <pre class="prettyprint w40 ctr">
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

    // Before...
    let es5Odds = numbers.filter(function(number) {
      return number % 2;
    });
    console.log(es5Odds);

    // After...
    let es6Odds = numbers.filter(number => number % 2);
    console.log(es6Odds);
</pre>
      <br />
      <p>Here we have an example of filter returning odds</p>
      <pre class="prettyprint w50 ctr">const someNums = [1, 2, 3, 4];
 const oddsOfSomeNums = someNums.filter(nums => nums % 2)
// 1 3
</pre>
      <br />


    </div>
    <hr>
    <div class="simple-wine-frame thin softwhite">
      <h3 class="chtitle">Template & tagged strings</h3>

      <h3 class="softwhite">A simple template string gives us this</h3>
      <pre class="prettyprint w80 txt-left ctr">
let num1 = 1;
let bool = true;
let sentence = `Fewer things are more ${bool} than that ${num1} plus ${num1} equals ${num1 + num1}`;
console.log(sentence);
// Fewer things are more true than that 1 plus 1 equals 2
</pre>

      <br />
      <h3 class="softwhite">Tagged strings</h3>
      <h3>The component parts of this string are these strings and values concatenated:</h3>
      <div class="dkbg w80 ctr ctrtxt brdr-w">
        <code class="ltgreen"><span class="underline">Fewer things are more </span><span class="softsand">${bool}</span><span class="underline"> than that </span><span class="softsand">${num1}</span><span class="underline"> plus </span><span class="softsand">${num1}</span><span class="underline"> equals </span><span class="softsand">${num1 + num1}</span><span class="ltred">_</span></code>
      </div>
      <br />

      <div class="chtitle softwhite med">Tagging strings gives us the power to "pre-process" the string.
        <br /> We create a function and 'call' that function with the template string as an argument that is
        <em>splayed</em> into it's component parts</div>
      <pre class="prettyprint w80 ctr">
...

let tagged = function(strArr, ...vals) {
  console.log(strArr); // ["Fewer things are more ", " than that ", " plus ", " equals ", "",]
  // Note the very last empty "" at the end of the array.
  console.log( vals); // [true, 1, 1, 2]
};

tagged`Fewer things are more ${bool} than that ${num1} plus ${num1} equals ${num1 + num1}`;
</pre>
      <hr>





    </div>
    <hr>
    <div class="plain-frame1">
      <h3 class="chtitle softred">ES6 Object Enhancement & .repeat() method</h3>
      <p>From ES5...</p>
      <pre class="prettyprint w30 ctr">const captainKirk = {
  orders: function(order) {
    console.log(`${order}`)
  }
}


captainKirk.orders("Make it so.")
</pre>
      <p>...to ES6</p>
      <pre class="prettyprint w30 ctr">
const captainKirk = {
  orders(order) {  // Remove ": function"
    console.log(`${order} `.repeat(5))
  }
}

captainKirk.orders("Make it so.")
</pre>
      <pre class="prettyprint w50 ctr">
// "Make it so. Make it so. Make it so. Make it so. Make it so. "
</pre>



    </div>
    <hr>
    <div class="simple-frame2">
      <h2 class="chtitle">Spread Operators</h2>
      <br />
      <h3 class="chtitle clean">Spread operators are used to expand an 'iterable object' when multiple items are expected.
        <br />They can be used in Fn calls, Parameter Lists, Array literals, Obj destructuring</h3>

      <br />
      <pre class="prettyprint w60 ctr"> let goodNewsArray = ["John", "Luke", "Mark", "Matthew"];

let guys = function(john="john", paul="paul", george="george", ringo="ringo") {
  return `${john}, ${paul}, ${george} & ${ringo}.`
}

console.log(guys(...goodNewsArray)) // John, Luke, Mark & Matthew.
</pre>

      <br />
      <br />
      <h3 class="ivr clean">These are also REALLY useful for Array Literals:</h3>
      <pre class="prettyprint ctr w60">
let beatlesArray = ["john", "paul", "george", "ringo"];

let charliesAngels = ["Kelly","Chris", "Sabrina", "Jill"];

let dateNight = [...beatlesArray, ...charliesAngels];

console.log(dateNight);
// (8) ["john", "paul", "george", "ringo", "Kelly", "Chris", "Sabrina", "Jill"]
</pre>
      <br />
      <hr>
      <h3 class="chtitle thin">The "Rest Parameter"</h3>
      The function below will join any limitless amount of parameters the spread allows us to take an arbitrary number of params!

      <pre class="prettyprint w50 ctr">  const joinUp = function(
    return words.join(' ');
  };
  console.log(joinUp('I', 'really', 'am', 'digging', 'es6!'));

  //I really am digging es6!
</pre>
      <br />
      <h3>A neat way to avoid the need for .split('');</h3>
      <pre class="framed8 dkbg wh thin w50 ctr">function joiningFunk(<span class="orange">...words</span>) {     <span class="orange">// (rest parameter)</span>
  return words.join(' ');
}

var joined = joiningFunk("I", "want", "to", "join", "these", "words");

console.log(joined); <span class="ltgreen">// I want to join these words</span>
</pre>
      <br />


    </div>
    <hr>
    <div class="framed5">
      <h2 class="chtitle ivr thin">Default Parameters</h2>

      <h2 class="thin">Default Parameter in a function declaration</h2>
      <br />
      <h4 class="paleY">At invocation if a param isn't passed--Function runs the default in the function signature...</h4>
      <pre class="prettyprint w50 linenums">
    function entree(fish = 'salmon') {
      console.log(`I think I'll have ${fish}`);
    }

    entree(); // I think I'll have the salmon

    entree('lobster'); // I think I'll have the lobster
  </pre>

      <br />
      <br>
      <h3 class="ctrtxt dkbg3 thin">running grunt es6 to create an es5 example gives us this very cool ternary condition</h3>

      <h3 class="brdr-w">var fish = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'salmon';</h3>

      <span class="sm ivr">if (
        <em>"there are more than zero args AND the first arg is NOT 'undefined', then run that first arg--Otherwise run it as
          'salmon'..."
        </em>)</span>

      <hr>
      <h2 class="thin">Default Parameter in a function expression -- With a bonus feature!</h2>
      <br />
      <h3 class="chtitle paleY">We can exploit this feature to add multiple default params
        <br> default parameters are 'visible' to following or later parameters in the same parameter list</h3>
      <pre class="prettyprint linenums">
var seinfeld = function(food = 'pretzels', adjective = 'thirsty', catchphrase = `These ${food} are making me ${adjective}`) {
  console.log(catchphrase);
};

console.log(seinfeld());
//These pretzels are making me thirsty

console.log(seinfeld('meatballs'));
//These meatballs are making me thirsty

console.log(seinfeld(undefined, 'sick'));
//These pretzels are making me sick  (If one param is undefined, it will run the default)
    </pre>

    </div>
    <hr>
    <pre>
  <div class="simple-frame2">
    <h3 class="chtitle thin">Block-scopes with <b class="lg wh">let</b> & <b class="lg wh">const</b>: a simple illustration   <br><a target="_blank" href="https://code.tutsplus.com/courses/javascript-es6-fundamentals" class="sm">(c/o Dan Wellman)</a></h3>
    <h4>Let's take a look at <em class="ivr">let</em></h4>
    <pre class="prettyprint w30">
'use strict';
(function() {
  console.log(block);

  if (true) {
    let block = 'block';
  }
})();
    </pre>
    <h5>This, of course, returns:
      <span class="ans med ltred">Uncaught ReferenceError: block is not defined (or not declared!)</span>
      Why? (hint: "var" wouldn't throw an error--simply "undefined") --because
      <span class="ans med ltred">log calls block but let prevents it from being hoisted.</span>
    </h5>


    <h6 class=" ctrtxt ivr">Even if the console.log(block) were
      <em>after</em> the if statement... it would still throw a ref error. </h6>

    <div class="dkbg3 w50 ctr brdr-w">
      <h5>Let has two features:
        <br /> 1) 'let' is to create scope to its containing block.
        <br /> 2) 'let' is not hoisted.
        <br />
      </h5>
      <h4>The temporal Dead-zone:</h4>
      <pre class="prettyprint w30 ctr">
'use strict';
(function() {

  if (true) {
    console.log(block);

    let block = 'block';
  }
})();
</pre>
      <h5>This, too, returns:
        <span class="med ltred">Uncaught ReferenceError: block is not defined (or not declared!)</span>
        <br /> Everything inside the block prior to the 'let' declaration is known as the
        <span class="orange comfort">"Temporal Dead-zone"</span>
      </h5>
    </div>
    <h4>Let's take a look at
      <em class="ivr">const</em>
    </h4> It's read-only whose value can't be changed thru reassignment or redeclaration. Like let variables, they are not hoisted.
    <h4 class="chtitle">Though immutable, passing by reference to change an Object's value
      <em>DOES</em> work:</h4>
    <pre class="prettyprint w50 ctr">  let obj = {
    testColor: 'Blue'
  };

  const refToObject_C = obj;

  obj.testColor = 'Fuchsia';

  console.log(refToObject_C); // {testColor: "Fuchsia"}</pre>
    <h5 class="orange">As discussed in the "ecma" view of this site... passing by reference is using an "alias" and so, changes a value indirectly
      using that alias.</h5>
  </div>
  <hr>
  <div class="framed6">
    <h1 class="chtitle thin softwhite">.map() with ES6</h1>
    <h4>Note:
      <em class="ivr">implicit return</em>
    </h4>
    <pre class="prettyprint w40 ctr">
var riceCrispies = [
  {character: "Snap!"},
  {character: "Crackle!"},
  {character: "Pop!"}
];

var cereal = riceCrispies.map(key => key.character);
// ["snap!", "Crackle!", "Pop!"]
</pre>

    <pre class="prettyprint w50 ctr">var array = [1,2,3,4,5,6];
// es5
let es5Arr = array.map(function(element) { return  element + 1});
console.log("ES5", es5Arr); // [73, 72, 59, 34, 43]

// es6
var arr3 = [10, 20, 30, 40, 50];
let es6Arr = arr3.map(element => element + 1);
console.log("es6", es6Arr); // [73, 72, 59, 34, 43]</pre>

    <div class="simple-frame">
      <h3>.map() with array of objects is very straightforward:</h3>
      <pre class="prettyprint w50">var people = [
  {name: "Sue",age: 23},
  {name: "Kim",age: 13},
  {name: "Joe",age: 21}
];

var ageArr = people.map(function(person){
  return person.age;
});
  // [23,13,21]</pre>
      <h3>And in es6</h3>
      <pre class="prettyprint w40">var ageArr = people.map(person => person.age;)</pre>
    </div>
  </div>
  <hr>
  <div class="simple-frame2">
    <h3 class="chtitle">The spread operator: ES6</h3> All you need is
    <span class="y">...</span> then
    <i class="y">varName</i>
    <pre class="prettyprint w80 col-2">function addItems(a, b, c) {

  if (typeof a === 'string') {
    console.log(`${a} ${b} ${c}`);

  } else if (typeof a === 'number') {
    console.log(a + b + c);
  }

}

var nums = [3, 4, 7];
//instead of addItems(nums[0], nums[1], nums[2]);
addItems(...nums); // 14

var fruit = ['apple', 'grape', 'pear', 'kiwi'];
// instead of addItems(nums[0], nums[1], nums[2]);
addItems(...fruit); // apple grape pear

// You can also join the arrays

var peanutButter = ["plain", "chunky", "organic"];
var jelly = ["strawberry", "apricot", "grape"];

var pbNj = [...peanutButter, ...jelly];

console.log(pbNj);
// ["plain", "chunky", "organic", "strawberry", "apricot", "grape"]
</pre>

  </div>
  <div class="framed5">
    <h3 class="chtitle ivr">The power of Object.assign()</h3>
    <pre class="prettyprint">
  var myStuff = { name: 'myStuff', a: 3, b: "puppies", c: 18, d: "babies", e: false, f: -1, g: "worms" };

function typeGroomer(input, test) {
  for (let prop in input) {
    if (typeof input[prop] !== test) {
      delete input[prop];
      var groomed = Object.assign({}, input);
    }
  }
  console.log(groomed);
  return groomed;
}
// let onlyNums =typeGroomer(myStuff, "number");
// let onlyBools = typeGroomer(myStuff, "boolean");
let onlyStrings =typeGroomer(myStuff, "string");
</pre> There is much more to Object.assign();
    <div class="dkbg pastOlive w40">
      <a class="sand" target="_blank" href="https://youtu.be/vM7Tif98Dlo">Here's a helpful link</a>
      <a class="sand" target="_blank" href="https://googlechrome.github.io/samples/object-assign-es6/">AND here</a>

    </div>
  </div>
  <div class="slate-skyblue-fr">
    <h3 class="chtitle">Template Literals</h3>
    <pre class="prettyprint w60">
const italian = {
  name: "Italians",
  meal: "pasta",
  pan: "pot",
  oil: "sesame",
  info: function() {
    console.log(`${this.name} cook ${this.meal} in a ${this.pan} with ${this.oil} oil.`);
  }
}
american.info(); // Americans cook chicken in a frying pan with corn oil.
</pre>
    <hr>
    <h3 class="chtitle underline">ES6 string methods:</h3>
    <h4 class="pastY">startsWith() endsWith() includes()</h4>
    <pre class="prettyprint w40">  italian.info().includes('cook'); // true
  italian.info().startsWith('cook'); // false
  italian.info().endsWith('oil.'); // true
</pre>

  </div>
  <div class="simple-frame2">
    <h2 class="ctrtxt">for of loops</h2> Plain es5 iteration:
    <pre class="prettyprint w40">
  var car = {
    color: "red",
    wheels: 4,
    transmission: "manual",
    domestic: false
  }

  for (var prop in car) {
    console.log(prop);
  } // color wheels transmission domestic
</pre>
    <em>for in</em> is for objects --but if you
    <b>must</b> use 'for of', this will work.
    <pre class="prettyprint w40">
  for (var prop of Object.keys(car)) {
    console.log(prop);
  }
</pre> for of is built for arrays
    <pre class="prettyprint w60">
  var carArr = [{color: "red"}, { wheels: 4}, {transmission: "manual"}, {domestic: false}];

  for (prop of carArr) {
    console.log(prop);
  }
  <img class="w20" src="./img/forof.jpg" alt="for of loop">
</pre>

  </div>
  <hr>
  <div class="framed3">
    <h2 class="pastY ctrtxt">Object destructuring & Array destructuring</h2> Object Destructuring:
    <pre class="prettyprint w40">
  var user = {
    name: "Alex",
    age: 34,
    job: "Farmer"
  };

  var {name, age, job} = user;
  console.log(name);
  console.log(age);
  console.log(job);
</pre> This is also useful with a function
    <pre class="prettyprint w40">
  function getTree() {
    return {
      residents: ['squirrel', 'robin family'],
      foliage: "leaves",
      branches: 14,
      age: 25
    }
  }

var {residents, foliage, brances, age} = getTree();
console.log(getTree());
// Object {
//  residents: Array(2),
//  foliage: "leaves",
//  branches: 14,
//  age: 25
// }
</pre> Array destructuring:
    <pre class="prettyprint w40">
  var arr = ["Alex", 34, "Farmer"];

  //old way...
  // var name = arr[0];
  // var age = arr[1];
  // var job = arr[2];

  //ES6
  var [name, age, job] = arr;
  console.log(job);
</pre>

  </div>
  <hr>
  <div class="slate-skyblue-fr">
    <h3 class="wh ctrtxt">Arrow Functions ("ow")</h3>

    <div class="brdr-w dkbg ctr ctrtxt">
      Let's remind ourselves of the brevity that arrow funcs allow for:

      <pre class="prettyprint w40 txt-left ctr">const emote = (icon) => console.log(`${icon}`);
  emote("🤓");
  // or... const emote = (icon) => console.log(icon);
  // 🤓</pre> Let's say I set up a func that takes two args:

      <pre class="prettyprint w40 txt-left ctr">function serve(iceCream, flavor) {
    iceCream(flavor);
  }</pre> I see in the body of the function that
      <code>serve()</code> is a function and it will subsequently take arg 2 (in the function signature). I have to call this "serve()" with
      two args. The clumsy way is thus:

      <code>serve(<span class="paleY underline">function defineFlavor(fruit) {console.log(fruit)}</span><sup class="wh">1</sup>, <span class="lightgreen">"🍋"</span><sup class="wh">2</sup>);</code> All of the extra text in arg
      <sup class="wh">1</sup> simply becomes "iceCream" in the function serve() above it. So it's MUCH, much simpler to remove all of that
      and use an anonymous function instead of all of that mess. Let's clean it up:

      <pre class="prettyprint w40">serve((fruit) => console.log(fruit), "🍋"); // 🍋</pre>
      <pre class="prettyprint w40">serve((fruit) => console.log(fruit), "🍓"); // 🍓</pre>
      <hr>

      <div class="simple-wine-frame w60 ctr txt-left">
        <pre class="prettyprint w40 txt-left ctr">var order = "Phasers on stun.";
var issueCommand = (order) => console.log(order);
var test = issueCommand(order);
// Phasers on stun.
</pre>
        <pre class="prettyprint w40 txt-left ctr">
var issueCommand = (order) => console.log(order);
issueCommand("Warp factor 2!");
// Warp factor 2!
</pre>
        <pre class="prettyprint w40 txt-left ctr">
var orders = "Make it so.";
var issueCommand = orders => orders; //Bare essence of ES6 Fn
var example = issueCommand(orders);
console.log(example);
// Make it so.
</pre>
        <p>The final ES6 funk has no return statement
          <em>("Implicit return")</em>
          <br />It has no "{}" or "()"</p>

      </div>
    </div>
    <hr> The following works in ES5:
    <pre class="prettyprint w40">
var people = [
  {name: "Sue",age: 23},
  {name: "Kim",age: 13},
  {name: "Joe",age: 21}
];

var ageArr = people.map(function(person){
  return person.age;
});
    // [23,13,21]
</pre> But in ES6, it's much cleaner code.
    <span class="y">IF you only have ONE argument</span>, don't use braces
    <br /> ALSO.
    <span class="y">If you are only returning one thing</span> and not doing other things in the Fn.
    <h3 class="ltred">GET RID OF the return statement and the "{}"</h3>
    <pre class="prettyprint w40">var ageArr = people.map(person => person.age;)</pre> Here is a promise callback using an Arrow Function.
    <span class="ivr">
      <em>Old way:</em>
    </span>
    <pre class="prettyprint w40">
$http.get(function('/api/people')
.then(function(data) {
  return res.data;
})</pre>
    <span class="mango">
      <em>New ES6 way:</em>
    </span>
    <pre class="prettyprint w40">
$http.get(function('/api/people')
.then(data => res.data)</pre> Don't use arrow functions as method on an object! 'this' breaks everything!
    <a href="https://vimeo.com/216583233" target="_blank">dm link about arrow functions and this</a>
  </div>
  <hr>
  <div class="plain-frame3">
    <h3 class="w60">The "let" keyword. var has 2 kinds of scope. Global and Lexical (or functional) scope.</h3>
    <span class="ivr">This code doesn't throw an error in es5.</span>
    <pre class="ctr prettyprint w40">
  var gimmeSum = function(sum) {
    if(sum) {
      var total = sum + 3;
    }
    return total;
  }
  gimmeSum(7)
  // 10</pre>
    <h3 class="caption">However, let variables are not implicity hoisted</h3>
    <pre class="ctr prettyprint w40">var gimmeSum = function(sum) {
    if(sum) {
      let total= sum + 3;
    }
    return total;
  }
  gimmeSum(7) // undefined b/c 'total' is block-scope
  </pre>
    <h3 class="caption">This can be solved by:</h3>
    <pre class="ctr prettyprint w20">if(sum) {
    let total = sum + total;
    return total;
  }</pre>
    <h3>
      <em class="wh">let</em>'s entire purpose is: block-scoping</h3>

  </div>

</div>
<!-- ES6 entry div end -->
</pre>
<!-- end of pre for entire page -->



</div>