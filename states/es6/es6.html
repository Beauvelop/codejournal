<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<div class="es6-container">
<aside><span class="rot90">{{state}}</span></aside>
<!-- pre for entire page -->

<!--
paste temp
-->
<div class="es6-entry entry">
<pre>
  <div class="framed6">
    <h3>.map() with ES6</h3>
    <h4>Note: <em class="ivr">implicit return</em></h4>
    <pre class="prettyprint w40">
    var riceCrispies = [
      {character: "Snap!"},
      {character: "Crackle!"},
      {character: "Pop!"}
    ];

    var cereal = riceCrispies.map(key => key.character);
          // ["snap!", "Crackle!", "Pop!"]
    </pre>

  </div>
  <div class="simple-frame2"><h3 class="chtitle">The spread operator: ES6</h3>
All you need is <span class="y">...</span> then <i class="y">varName</i>
    <pre class="prettyprint w80 col-2">function addItems(a, b, c) {

  if (typeof a === 'string') {
    console.log(`${a} ${b} ${c}`);

  } else if (typeof a === 'number') {
    console.log(a + b + c);
  }

}

var nums = [3, 4, 7];
//instead of addItems(nums[0], nums[1], nums[2]);
addItems(...nums); // 14

var fruit = ['apple', 'grape', 'pear', 'kiwi'];
// instead of addItems(nums[0], nums[1], nums[2]);
addItems(...fruit); // apple grape pear

// You can also join the arrays

var peanutButter = ["plain", "chunky", "organic"];
var jelly = ["strawberry", "apricot", "grape"];

var pbNj = [...peanutButter, ...jelly];

console.log(pbNj);
// ["plain", "chunky", "organic", "strawberry", "apricot", "grape"]
</pre>

  </div>
<div class="framed5"><h3 class="chtitle ivr">The power of Object.assign()</h3>
  <pre class="prettyprint">
  var myStuff = { name: 'myStuff', a: 3, b: "puppies", c: 18, d: "babies", e: false, f: -1, g: "worms" };

function typeGroomer(input, test) {
  for (let prop in input) {
    if (typeof input[prop] !== test) {
      delete input[prop];
      var groomed = Object.assign({}, input);
    }
  }
  console.log(groomed);
  return groomed;
}
// let onlyNums =typeGroomer(myStuff, "number");
// let onlyBools = typeGroomer(myStuff, "boolean");
let onlyStrings =typeGroomer(myStuff, "string");
</pre>
There is much more to Object.assign();
<div class="dkbg pastOlive w40">
<a class="sand" target="_blank" href="https://youtu.be/vM7Tif98Dlo">Here's a helpful link</a>
<a class="sand" target="_blank" href="https://googlechrome.github.io/samples/object-assign-es6/">AND here</a>

</div>
</div>
<div class="slate-skyblue-fr"><h3 class="chtitle">Template Literals</h3>
  <pre class="prettyprint w60">
const italian = {
  name: "Italians",
  meal: "pasta",
  pan: "pot",
  oil: "sesame",
  info: function() {
    console.log(`${this.name} cook ${this.meal} in a ${this.pan} with ${this.oil} oil.`);
  }
}
american.info(); // Americans cook chicken in a frying pan with corn oil.
</pre><hr>
<h3 class="chtitle underline">ES6 string methods:</h3>
<h4 class="pastY">startsWith() endsWith() includes()</h4>
<pre class="prettyprint w40">  italian.info().includes('cook'); // true
  italian.info().startsWith('cook'); // false
  italian.info().endsWith('oil.'); // true
</pre>

</div>
<div class="simple-frame2"><h2 class="ctrtxt">for of loops</h2>
Plain es5 iteration:
<pre class="prettyprint w40">
  var car = {
    color: "red",
    wheels: 4,
    transmission: "manual",
    domestic: false
  }

  for (var prop in car) {
    console.log(prop);
  } // color wheels transmission domestic
</pre>
<em>for in</em> is for objects --but if you <b>must</b> use 'for of', this will work.
<pre class="prettyprint w40">
  for (var prop of Object.keys(car)) {
    console.log(prop);
  }
</pre>

for of is built for arrays
<pre class="prettyprint w60">
  var carArr = [{color: "red"}, { wheels: 4}, {transmission: "manual"}, {domestic: false}];

  for (prop of carArr) {
    console.log(prop);
  }
  <img class="w20" src="./img/forof.jpg" alt="for of loop">
</pre>

</div>
<hr>
<div class="framed3"><h2 class="pastY ctrtxt">Object destructuring & Array destructuring</h2>
Object Destructuring:
<pre class="prettyprint w40">
  var user = {
    name: "Alex",
    age: 34,
    job: "Farmer"
  };

  var {name, age, job} = user;
  console.log(name);
  console.log(age);
  console.log(job);
</pre>
This is also useful with a function
<pre class="prettyprint w40">
  function getTree() {
    return {
      residents: ['squirrel', 'robin family'],
      foliage: "leaves",
      branches: 14,
      age: 25
    }
  }

var {residents, foliage, brances, age} = getTree();
console.log(getTree());
// Object {
//  residents: Array(2),
//  foliage: "leaves",
//  branches: 14,
//  age: 25
// }
</pre>

Array destructuring:
<pre class="prettyprint w40">
  var arr = ["Alex", 34, "Farmer"];

  //old way...
  // var name = arr[0];
  // var age = arr[1];
  // var job = arr[2];

  //ES6
  var [name, age, job] = arr;
  console.log(job);
</pre>

</div>
<hr>
<div class="slate-skyblue-fr">
<h3 class="wh ctrtxt">Arrow Functions ("fat-arrow")</h3>

<div class="brdr-w dkbg ctr ctrtxt">
  Let's remind ourselves of the brevity that arrow funcs allow for:

  <pre class="prettyprint w40 txt-left ctr">const emote = (icon) => console.log(`${icon}`);
  emote("ü§ì");
  // or... const emote = (icon) => console.log(icon);
  // ü§ì</pre>

  Let's say I set up a func that takes two args:

  <pre class="prettyprint w40 txt-left ctr">function serve(iceCream, flavor) {
    iceCream(flavor);
  }</pre>

  I see in the body of the function that <code>serve()</code> is a function and it will subsequently take arg 2 (in the function signature).

  I have to call this "serve()" with two args.

  The clumsy way is thus:

  <code>serve(<span class="paleY underline">function defineFlavor(fruit) {console.log(fruit)}</span><sup class="wh">1</sup>, <span class="lightgreen">"üçã"</span><sup class="wh">2</sup>);</code>

  All of the extra text in arg <sup class="wh">1</sup> simply becomes "iceCream" in the function serve() above it.

  So it's MUCH, much simpler to remove all of that and use an anonymous function instead of all of that mess.

  Let's clean it up:

  <pre class="prettyprint w40">serve((fruit) => console.log(fruit), "üçã"); // üçã</pre>
  <pre class="prettyprint w40">serve((fruit) => console.log(fruit), "üçì"); // üçì</pre>

</div><hr>

The following works in ES5:
<pre class="prettyprint w40">
var people = [
  {name: "Sue",age: 23},
  {name: "Kim",age: 13},
  {name: "Joe",age: 21}
];

var ageArr = people.map(function(person){
  return person.age;
});
    // [23,13,21]
</pre>
But in ES6, it's much cleaner code.
<span class="y">IF you only have ONE argument</span>, don't use braces<br />
ALSO. <span class="y">If you are only returning one thing</span> and not doing other things in the Fn.
<h3 class="ltred">GET RID OF the return statement and the "{}"</h3>
<pre class="prettyprint w40">var ageArr = people.map(person => person.age;)</pre>

Here is a promise callback using an Arrow Function.
<span class="ivr"><em>Old way:</em></span>
<pre class="prettyprint w40">
$http.get(function('/api/people')
.then(function(data) {
  return res.data;
})</pre>
<span class="mango"><em>New ES6 way:</em></span>
<pre class="prettyprint w40">
$http.get(function('/api/people')
.then(data => res.data)</pre>
Don't use arrow functions as method on an object! 'this' breaks everything!
<a href="https://vimeo.com/216583233" target="_blank">dm link about arrow functions and this</a>
</div>
  <hr>
<div class="plain-frame3">
  <h3 class="w60">The "let" keyword.
  var has 2 kinds of scope. Global and Lexical (or functional) scope.</h3>
  <span class="ivr">This code doesn't throw an error in es5.</span>
  <pre class="ctr prettyprint w40">
  var gimmeSum = function(sum) {
    if(sum) {
      var total = sum + 3;
    }
    return total;
  }
  gimmeSum(7)
  // 10</pre>
  <h3 class="caption">However, let variables are not implicity hoisted</h3>
  <pre class="ctr prettyprint w40">var gimmeSum = function(sum) {
    if(sum) {
      let total= sum + 3;
    }
    return total;
  }
  gimmeSum(7) // undefined b/c 'total' is block-scope
  </pre>
  <h3 class="caption">This can be solved by:</h3>
  <pre class="ctr prettyprint w20">if(sum) {
    let total = sum + total;
    return total;
  }</pre>
  <h3><em class="wh">let</em>'s entire purpose is: block-scoping</h3>

</div>

</div>
<!-- ES6 entry div end -->
</pre>
<!-- end of pre for entire page -->



</div>
