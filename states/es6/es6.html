<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<div class="es6-container">
<aside><span class="rot90">{{state}}</span></aside>
<!-- pre for entire page -->

<!--
paste temp
-->
<div class="es6-entry entry">
<pre>
  <div class="framed6">
    <h3>.map() with ES6</h3>
    <h4>Note: <em class="ivr">implicit return</em></h4>
    <pre class="prettyprint w40">
    var riceCrispies = [
      {character: "Snap!"},
      {character: "Crackle!"},
      {character: "Pop!"}
    ];

    var cereal = riceCrispies.map(key => key.character);
          // ["snap!", "Crackle!", "Pop!"]
    </pre>

  </div>
  <div class="simple-frame2"><h3 class="chtitle">The spread operator: ES6</h3>
All you need is <span class="y">...</span> then <i class="y">varName</i>
    <pre class="prettyprint w80 col-2">function addItems(a, b, c) {

  if (typeof a === 'string') {
    console.log(`${a} ${b} ${c}`);

  } else if (typeof a === 'number') {
    console.log(a + b + c);
  }

}

var nums = [3, 4, 7];
//instead of addItems(nums[0], nums[1], nums[2]);
addItems(...nums); // 14

var fruit = ['apple', 'grape', 'pear', 'kiwi'];
// instead of addItems(nums[0], nums[1], nums[2]);
addItems(...fruit); // apple grape pear

// You can also join the arrays

var peanutButter = ["plain", "chunky", "organic"];
var jelly = ["strawberry", "apricot", "grape"];

var pbNj = [...peanutButter, ...jelly];

console.log(pbNj);
// ["plain", "chunky", "organic", "strawberry", "apricot", "grape"]
</pre>

  </div>
<div class="framed5"><h3 class="chtitle ivr">The power of Object.assign()</h3>
  <pre class="prettyprint">
  var myStuff = { name: 'myStuff', a: 3, b: "puppies", c: 18, d: "babies", e: false, f: -1, g: "worms" };

function typeGroomer(input, test) {
  for (let prop in input) {
    if (typeof input[prop] !== test) {
      delete input[prop];
      var groomed = Object.assign({}, input);
    }
  }
  console.log(groomed);
  return groomed;
}
// let onlyNums =typeGroomer(myStuff, "number");
// let onlyBools = typeGroomer(myStuff, "boolean");
let onlyStrings =typeGroomer(myStuff, "string");
</pre>
There is much more to Object.assign();
<div class="dkbg pastOlive w40">
<a class="sand" target="_blank" href="https://youtu.be/vM7Tif98Dlo">Here's a helpful link</a>
<a class="sand" target="_blank" href="https://googlechrome.github.io/samples/object-assign-es6/">AND here</a>

</div>
</div>
<div class="framed4"><h3 class="chtitle">Template Literals</h3>
  <pre class="prettyprint w60">
const italian = {
  name: "Italians",
  meal: "pasta",
  pan: "pot",
  oil: "sesame",
  info: function() {
    console.log(`${this.name} cook ${this.meal} in a ${this.pan} with ${this.oil} oil.`);
  }
}
american.info(); // Americans cook chicken in a frying pan with corn oil.
</pre><hr>
<h3 class="chtitle underline">ES6 string methods:</h3>
<h4 class="pastY">startsWith() endsWith() includes()</h4>
<pre class="prettyprint w40">  italian.info().includes('cook'); // true
  italian.info().startsWith('cook'); // false
  italian.info().endsWith('oil.'); // true
</pre>

</div>
<div class="simple-frame2"><h2 class="ctrtxt">for of loops</h2>
Plain es5 iteration:
<pre class="prettyprint w40">
  var car = {
    color: "red",
    wheels: 4,
    transmission: "manual",
    domestic: false
  }

  for (var prop in car) {
    console.log(prop);
  } // color wheels transmission domestic
</pre>
<em>for in</em> is for objects --but if you <b>must</b> use 'for of', this will work.
<pre class="prettyprint w40">
  for (var prop of Object.keys(car)) {
    console.log(prop);
  }
</pre>

for of is built for arrays
<pre class="prettyprint w60">
  var carArr = [{color: "red"}, { wheels: 4}, {transmission: "manual"}, {domestic: false}];

  for (prop of carArr) {
    console.log(prop);
  }
  <img class="w20" src="./img/forof.png" alt="for of loop">
</pre>

</div>
<hr>
<div class="framed3"><h2 class="pastY ctrtxt">Object destructuring & Array destructuring</h2>
Object Destructuring:
<pre class="prettyprint w40">
  var user = {
    name: "Alex",
    age: 34,
    job: "Farmer"
  };

  var {name, age, job} = user;
  console.log(name);
  console.log(age);
  console.log(job);
</pre>
This is also useful with a function
<pre class="prettyprint w40">
  function getTree() {
    return {
      residents: ['squirrel', 'robin family'],
      foliage: "leaves",
      branches: 14,
      age: 25
    }
  }

var {residents, foliage, brances, age} = getTree();
console.log(getTree());
// Object {
//  residents: Array(2),
//  foliage: "leaves",
//  branches: 14,
//  age: 25
// }
</pre>

Array destructuring:
<pre class="prettyprint w40">
  var arr = ["Alex", 34, "Farmer"];

  //old way...
  // var name = arr[0];
  // var age = arr[1];
  // var job = arr[2];

  //ES6
  var [name, age, job] = arr;
  console.log(job);
</pre>

</div>
<hr>
<div class="framed4">
<h3 class="wh ctrtxt">Arrow Functions ("fat-arrow")</h3>
The following works in ES5:
<pre class="prettyprint w40">
var people = [
  {name: "Sue",age: 23},
  {name: "Kim",age: 13},
  {name: "Joe",age: 21}
];

var ageArr = people.map(function(person){
  return person.age;
});
    // [23,13,21]
</pre>
But in ES6, it's much cleaner code.
<span class="y">IF you only have ONE argument</span>, don't use parentheses<br />
ALSO. <span class="y">If you are only returning one thing</span> and not doing other things in the Fn.
<h3 class="ltred">GET RID OF the return statement and the "{}"</h3>
<pre class="prettyprint w40">var ageArr = people.map(person => person.age;)</pre>

Here is a promise callback using an Arrow Function.
<span class="ivr"><em>Old way:</em></span>
<pre class="prettyprint w40">
$http.get(function('/api/people')
.then(function(data) {
  return res.data;
})</pre>
<span class="mango"><em>New ES6 way:</em></span>
<pre class="prettyprint w40">
$http.get(function('/api/people')
.then(data => res.data)</pre>
</div>
Don't use arrow functions as method on an object! 'this' breaks everything!
<a href="https://vimeo.com/216583233" target="_blank">dm link about arrow functions and this</a>
  <hr>
<h3 class="w60">The "let" keyword.
var has 2 kinds of scope. Global and Lexical (or functional) scope.</h3>
<span class="ivr">This code doesn't throw an error in es5.</span>
<pre class="prettyprint w40">
var gimmeSum = function(sum) {
  if(sum) {
    var total = sum + 3;
  }
  return total;
}
gimmeSum(7)
// 10</pre>
<h3 class="caption">However, let variables are not implicity hoisted</h3>
<pre class="prettyprint w20">var gimmeSum = function(sum) {
  if(sum) {
    let total= sum + 3;
  }
  return total;
}
gimmeSum(7) // undefined b/c 'total' is block-scope
</pre>
<h3 class="caption">This can be solved by:</h3>
<pre class="prettyprint w20">if(sum) {
  let total = sum + total;
  return total;
}</pre>
<h3><em class="wh">let</em>'s entire purpose is for block-scoping</h3>


</div>
<!-- ES6 entry div end -->
</pre>
<!-- end of pre for entire page -->



</div>
