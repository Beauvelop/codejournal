<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<div class="gsap-container">
  <aside><span class="rot90">{{state}}</span></aside>
  <div class="gsap-entry entry">
    <pre>
<!--entire page pre-->
<div class="framed4"><h3>A loader animation with GSAP</h3>
First we need a bit of html <b class="paleY">at the top of <span><</span>body></b>
<div class="col-2 brdr-w"><pre class="dkbg w30">
< div id="loader">

  < div class="dot">< / div>

  < div class="dot">< / div>

  < div class="dot">< / div>

  < div class="dot">< / div>

  < div class="dot">< / div>

  < div class="dot">< / div>

< / div>
</pre>
<pre class="dkbg w30">
#loader{
    <span class="paleY">position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);</span>

      .dot {
          width: 12px;
          height: 12px;
          display: inline-block;
          border-radius: 100%;
          margin-right: 6px;
          border: 2px solid teal;
      }
}
</pre>
</div>



TimelineMax is required to configure the number of repeats of the a given timeline.
The object passed in the <code>new TimelineMax()</code> method can also have a onComplete property
<pre class="prettyprint w50">
tlLoader = new TimelineMax({ repeat: 3, onComplete:onComplete })</pre>

</div>
<div class="lt-frame"><h3 class="chtitle dkblue">GSAP's Stagger Methods</h3>
The Problem: I have all these individual elements (btns) that I want to stagger into frame.
I have to code their tweens individually...<pre class="prettyprint w40">var tl2 = new TimelineMax();
tl2
  .from(play, 1, {y: -60, ease: Power4.easeIn}, 1)
  .from(pause, 1, {y: -60, ease: Power4.easeIn}, '-=.2')
  .from(resume, 1, {y: -60, ease: Power4.easeIn}, '-=.2');</pre>This is both messy and inefficient.

The Solution: GSAP's stagger method or "stagger tween".<pre class="prettyprint w50">  var tl2 = new TimelineMax();
  var button = $('button');
  tl2.staggerFrom(button, .5, {y: -100, ease:Power4.easeOut}, 0.1);</pre>
üí•Boom! --3 lines of code.
<h4 class="paleY">Of course, there's also <code class="wh">.staggerTo</code> and <code class="wh">.staggerFromTo</code> which requires two abscissa objects</h4>
<pre class="dkbg w20"><code class="sm paleY">
tl2.<span class="ltgreen">staggerFromTo</span>(button, .5,
      {autoAlpha: 0,
               y: -100,
            ease:Power4.easeOut
      },
      {autoAlpha: 1,
               y:600
      }, 0.1);</code></pre>
<h3 class="dkred">(In fact, <code>autoAlpha 0</code> is superfluous, here. So let's refactor.)</h3>
Or, simply...

<code class="ctr dkred ltbg3">tl2.staggerFromTo(button, .5, {y: -100, ease:Power4.easeOut}, {autoAlpha: 1, y:600}, 0.1);</code><br>
<h2 class="navy">Stagger: 'Cycle':</h2>(Returning to staggerFrom...)

GSAP's powerful "cycle" property will take an attribute--give it two values and distribute it to alternating tweens.
<pre class="prettyprint w80">  tl2.staggerFrom(button, 5, { cycle:{x:[-100, 500, 1800]}, ease:Power4.easeOut}, {autoAlpha: 1, y:600}, 0.1);</pre>
Here we will have buttons appear from 3 different directions.

<h3 class="dkorange">One more cool example:</h3>
We can even cycle through multiple properties. Here, we'll do scale and x
<pre class="dkbg ctrtxt w80">tl2.staggerFrom(button, 5, { <b class="ltgreen">cycle:{x:[-100, 500]</b>, <b class="ltblue">scale: [2, 0.5] </b>}, ease:Power4.easeOut}, {autoAlpha: 1, y:600}, 0.1);</pre>
So, twice the size and half the size (is the style rules that they 'come from'). They then arrive at a uniform height and position.
</div>
<div class="framed1"><h3>Useful methods to control events in a timeline</h3>
In <a href="https://codepen.io/beau_dev/pen/dRYJjm?editors=0010">This Pen</a>, You'll find the following Fn calls placed inside various click events.


<div class="col-2"><pre class="w40 brdr-dk">tl.play();
tl.pause();<b class="ltred med">*</b>
tl.play(0).pause();
tl.resume();
tl.reverse();
tl.timeScale(6);
tl.timeScale(1 / 2);
tl.play(3);
tl.play("aftertwo");
</pre>
<pre class="w40 brdr-dk pastY">--run timeline
--stop timeline midstream
--reset to start
--resume timeline
--reverse mid-stream
--speed up by a multiple
--will slow down (if divisor) --will reverse if neg. (or decimal < 1)
--plays sending a second mark as an arg
--plays sending a named var (a 'label') as an arg</pre>
</div>

For example on the 'reverse' button... <pre class="prettyprint w40">reverse.on("click", function() {
    tl.reverse();
  });</pre>

<b class="ltred med">*</b> Another way to pause a timeline is with (<span>Be sure to type 'pause<b class="ltred">d</b>'</span>)
<pre class="prettyprint w20">tl = new TimelineLite({paused: true})</pre>

<h3 class="ltblue">‚òØÔ∏èHow to repeat timelines infinitely!‚òØÔ∏è</h3>
ltLoader = new TimelineMax({repeat: -1});
<h5 class="wh">TimelineMax is required for repeating and is perfect for loaders</h5>
TimelineMax enables the repeat object in order to set the amount of repeats. (-1) is the value for infinite repeat.

</div>
<hr>
<div class="framed1 dk-frame"><h3 class="chtitle pastY">GSAP Callbacks are very simple</h3>
Inside of the tween's object place a key:value pair. Key is the Fn name, Value is the arg.
<div class="col-2">
Comma separated key:values are permissable as well.
<pre class="prettyprint w40">
...
.to(eight, 2, { y: 262, x: 850, ease: Power1.easeOut, onStart:poop }, "-=0.5")
...</pre>
Then, the function definition below...
<pre class="prettyprint w40">
function poop() {
  console.log("Eight has started!");
}
//"poop", of course, is an arbitrary value name. :)</pre>
</div>

<pre class="w50">GSAP callbacks give you 3 choices:

{ ... , onStart:<em class="ltblue">funkName</em> }<br>
<code>function <span class="ltblue">funkName</span>() { console.log("Started!")}</code>

{ ... , onUpdate:<em class="sand">funkName</em> }<br>
<code>function <span class="sand">funkName</span>() { console.log("We're running!")}</code>

{ ... , onComplete:<em class="ltred">funkName</em> }<br>
<code>function <span class="ltred">funkName</span>() { console.log("Done!")}</code></pre>
</div>

<h1 class="chtitle dkblue">First, The Set-Up...</h1>
<div class="ctr shadn brdr-w ltbg ivr w50 sm">
<span><</span>script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"><span></</span>script>

<span><</span>script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TweenMax.min.js"><span></</span>script>

</div><br>
A simple example...
<div class="col-2"><pre class="prettyprint w40">
(function($) {

  var header = $('header');
  TweenMax.from(header, 2, {autoAlpha: 0, y: -300});
  // this line is referred to as a 'tween'

}(jQuery))</pre>
<pre class="w40">
JQ

selector on a var
method on <code><i class="ltgreen">TMax</i>(<i class="orange">selector</i>,<i class="sand">duration</i>, <i class="paleY">Object & attrs</i> )</code>


</pre>
</div><hr>
<h1 class="chtitle">Anatomy of a Greensock ease:</h1>
<h2 class="chtitle pastpink">TweenLite.from(img, 1, {x: -200, <b class="paleY">ease</b>:<span class="ltgreen">Power4</span><b class="dkred">.easeOut</b>});</h2>
<div class="col-3 dk-frame">
  <pre><b class="fuch">I.</b>

POWER refers to duration
and goes from Power0 ~ Power4


  </pre>
<pre>

<b class="fuch">II.</b>
easeNone
easeIn
easeOut
easeInOut
Back.easeOut
Bounce.easeOut
Circ.easeOut
Elastic.easeOut
Expo.easeOut
Sine.easeOut</pre>
  <pre><b class="fuch">III.</b>
The following three are tricky.

RoughEase
Slomo
SteppedEase

These can be tinkered with easily @
<a href="https://greensock.com/ease-visualizer" target="_blank">Greensock's ease visualizer</a>
</pre>
</div>
üí°NOTA BENE: roughEase would be great to animate a flourescent light cutting out and blinking back on!

<hr>
<h1 class="chtitle">Methods of Greensock:</h1>
<h2 class="chtitle pastpink">TweenMax<span class="pastY">.from</span>(header, 3, {autoAlpha: 0, x: 200, ease:Elastic.easeIn});</h2>
<div class="framed6">
<div class="col-2 simple-frame2 w60 ctr"><pre class="paleY">.to()
.from()
.set()
.fromTo()
autoAlpha
</pre>
<pre class="wh">
specifies end point
specifies start point
exactly like .css()<em> no animation</em>
reqires 2 values for start & end
opacity
</pre>
</div>
<b class="purp">.fromTo()</b><pre class="prettyprint w20">
tm.fromTo(img, 3,
 { x: 200, y: -300 },
 { x: -200, y: 500 });
</pre>
<b class="purp">.set()</b><pre class="prettyprint w30">
// Remove timing val
tm.set(img,{ x: 200, y: -300 });
</pre>
the <span class="paleY">delays</span> here render this in succession
<div class="plain-frame0 ctr w30">  tm.from(h1, 3, { x: 200, y: -300 });
  tm.from(h3, 1, { x:-500, <span class="paleY">delay</span>: 4 });
  tm.from(h2, 1, { x:-500, <span class="paleY">delay</span>: 3 });
</div>

</div>
<hr>
<h1 class="chtitle">Configuring timeline events with precision</h1>
<div class="brdr-w shadn">

<h4 class="med">We alter the delay to have them overlap
Here, each subsequent animation starts <i class="navy">'0.5' seconds</i> before the previous one ends</h4>
<pre class="ctr dkbg w60">tl.from(h1, 1, {y: -15}, <i class="ltblue">'-=0.5'</i> )
                            .from(h2, 1, {y: -15}, <i class="ltblue">'-=0.5'</i> )
                            .from(h3, 1, {y: -15}, <i class="ltblue">'-=0.5'</i> )
                            .from(h4, 1, {y: -15}, <i class="ltblue">'-=0.5'</i> )
                            .from(h5, 1, {y: -15}, <i class="ltblue">'-=0.5'</i> );
</pre>
<h2><b class="wh med">Absolute Positioning</b> of timelines is easy to understand:</h2>
<p>REGARDLESS of other events, I want my h4 to run at 4 seconds. The rest can fire off as they like.</p>
<pre class="prettyprint dkbg w40 linenums">
var animation = new TimelineLite();

animation.from(img, 3, {y: -15} )
         .from(h2, 3, {y: -15}, '-=2' )
         .from(span, 3, {y: -15}, '+=4' )
         .from(h4, 3, {y: -15}, 4 );
</pre>
The span will fire AFTER the Abs-positioned h4.

<h2 class="ctr wh">Labeling of delays</h2>

<h3>This simply shows that labeling another animation (bottom) and then inserting with <em>.add()</em> will control where it fires in the timeline.</h3>
<div class="col-2">
<pre class="dkbg w40">
animation.from(span, 2, {y: -15, autoAlpha: 0} )
   <span class="ltgreen">.add(poop)</span>
   .from(h2, 2, {y: -15, autoAlpha: 0} )
   .from(h4, 2, {y: -15, autoAlpha: 0} )
   .from(img, 2, {y: -15, autoAlpha: 0}, '<span class="ltgreen">poop</span>' );

</pre>

<pre class="w40 shadn">
<h3 class="sand">Here, 'img' will fire immediately after 'span'.

.add() acts as an alias of that bottom animation
'<span class="ltgreen">poop</span>', of course, is an arbitrary 'var' name</h3></pre>

</div>
<br>
<h3 class="orange">Infact, we can label any one of them and even modify them with an expression individually in quotes</h3>
<pre class="ctr dkbg w40">
animation.from(<span class="wh">span</span>, 2, {y: -15, autoAlpha: 0} )
   <span class="wh">.add(span)</span>
   .from(h2, 2, {y: -15, autoAlpha: 0}, <span class="wh">'span'</span> )
   .from(h4, 2, {y: -15, autoAlpha: 0}, <span class="orange">'span+=2'</span> )
   .from(img, 2, {y: -15, autoAlpha: 0}, <span class="wh">'span'</span> );
</pre>

</div>







</pre>
<!--entire page pre-->
</div>


</div>
